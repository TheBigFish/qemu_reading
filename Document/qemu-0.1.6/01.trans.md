至少在qemu0.1.6版本,字节码的转换流程十分简洁.

首先读取原始的i386字节码,转换成中间字节码,然后将中间字节码转换成目的字节码,在这里目的字节码就是i386.

为了方便读代码,这里列举一下,比较重要的一些函数:

disas_insn 将原始字节码转换为中间字节码

dyngen_code 将中间字节码转换成目的字节码

如何从字节码中解析出汇编指令,可能需要查看手册,这里不过多涉及.




```c
enum {
#define DEF(s, n) INDEX_op_ ## s,
#include "opc-i386.h"
#undef DEF
    NB_OPS,
};

```

```c
DEF(movl_A0_EAX, 0)
DEF(addl_A0_EAX, 0)
```

代码可以翻译一下:

```c
enum {
	INDEX_op_movl_A0_EAXs,
    INDEX_op_addl_A0_EAXs,
    NB_OPS,
};
```



```c
typedef void (GenOpFunc)(void);
typedef void (GenOpFunc1)(long);
typedef void (GenOpFunc2)(long, long);
```





```c
#define STRINGOP(x) \
    gen_op_ ## x ## b_fast, \
    gen_op_ ## x ## w_fast, \
    gen_op_ ## x ## l_fast, \
    gen_op_ ## x ## b_a32, \
    gen_op_ ## x ## w_a32, \
    gen_op_ ## x ## l_a32, \
    gen_op_ ## x ## b_a16, \
    gen_op_ ## x ## w_a16, \
    gen_op_ ## x ## l_a16,
```

因此:

```c
static GenOpFunc *gen_op_movs[9 * 2] = {
    STRINGOP(movs)
    STRINGOP(rep_movs)
};

static GenOpFunc *gen_op_stos[9 * 2] = {
    STRINGOP(stos)
    STRINGOP(rep_stos)
};

static GenOpFunc *gen_op_lods[9 * 2] = {
    STRINGOP(lods)
    STRINGOP(rep_lods)
};

static GenOpFunc *gen_op_scas[9 * 3] = {
    STRINGOP(scas)
    STRINGOP(repz_scas)
    STRINGOP(repnz_scas)
};

static GenOpFunc *gen_op_cmps[9 * 3] = {
    STRINGOP(cmps)
    STRINGOP(repz_cmps)
    STRINGOP(repnz_cmps)
};

static GenOpFunc *gen_op_ins[9 * 2] = {
    STRINGOP(ins)
    STRINGOP(rep_ins)
};


static GenOpFunc *gen_op_outs[9 * 2] = {
    STRINGOP(outs)
    STRINGOP(rep_outs)
};
```

为了简单起见,我们仅仅翻译一下gen_op_movs:

```c
static GenOpFunc *gen_op_movs[9 * 2] = {
    gen_op_movsb_fast,
    gen_op_movsw_fast,
    gen_op_movsl_fast,
    gen_op_movsb_a32,
    gen_op_movsw_a32,
    gen_op_movsl_a32,
    gen_op_movsb_a16,
    gen_op_movsw_a16,
    gen_op_movsl_a16,
    
    gen_op_rep_movsb_fast,
    gen_op_rep_movsw_fast,
    gen_op_rep_movsl_fast,
    gen_op_rep_movsb_a32,
    gen_op_rep_movsw_a32,
    gen_op_rep_movsl_a32,
    gen_op_rep_movsb_a16,
    gen_op_rep_movsw_a16,
    gen_op_rep_movsl_a16, 
};
```

你是不是很好奇,这些函数都是在哪里定义的?答案是op-i386.h, 需要注意的是,这个是编译后生成的文件.



im代表立即数.
关于T0, T1, A0, 这些其实是寄存器变量,或者,你直接认为是寄存器也没有啥问题.

```c
// exec-i386.h
register unsigned int T0 asm("ebx");
register unsigned int T1 asm("esi");
register unsigned int A0 asm("edi");
register struct CPUX86State *env asm("ebp");

extern int __op_param1, __op_param2, __op_param3;
#define PARAM1 ((long)(&__op_param1))
#define PARAM2 ((long)(&__op_param2))
#define PARAM3 ((long)(&__op_param3))


// exec-i386.c
static uint16_t *gen_opc_ptr;
static uint32_t *gen_opparam_ptr;
int __op_param1, __op_param2, __op_param3;
```

## mov

将T1的值移动到T0之中.

```c
            case INDEX_op_movl_T0_T1:
            {
                extern void op_movl_T0_T1();
                memcpy(gen_code_ptr, &op_movl_T0_T1, 2);
                gen_code_ptr += 2;
            }
			break;
            case INDEX_op_movl_T1_im: /* 将立即数移动到寄存器T1之中 */
            {
                long param1;
                extern void op_movl_T1_im();
                memcpy(gen_code_ptr, &op_movl_T1_im, 5);
                param1 = *opparam_ptr++;
                *(uint32_t *)(gen_code_ptr + 1) = param1 + 0;
                gen_code_ptr += 5;
            }
            break;
```



```c
void OPPROTO op_movl_T0_T1(void)
{
    T0 = T1;
}

void OPPROTO op_movl_T1_im(void)
{
    T1 = PARAM1; /* 将参数1的值移动到寄存器T1之中 */
}
```

## ld



```c
// cpu-i386.h
/* all CPU memory access use these macros */
static inline int ldub(void *ptr) /* 加载无符号的字节 */
{
    return *(uint8_t *)ptr;
}

static inline int ldsb(void *ptr) /* 加载有符号的字节 */
{
    return *(int8_t *)ptr;
}

static inline int lduw(void *ptr) /* 加载无符号的2个字节 */
{
    return *(uint16_t *)ptr;
}

static inline int ldsw(void *ptr) /* 加载有符号的2个字节 */
{
    return *(int16_t *)ptr;
}

static inline int ldl(void *ptr) /* 加载无符号的4个字节 */
{
    return *(uint32_t *)ptr;
}

static inline uint64_t ldq(void *ptr) /* 加载无符号的8个字节 */
{
    return *(uint64_t *)ptr;
}
```



```c
            case INDEX_op_ldsb_T0_A0: /* [A0] -> T0 有符号,1字节 */
            {
                extern void op_ldsb_T0_A0();
                memcpy(gen_code_ptr, &op_ldsb_T0_A0, 3);
                gen_code_ptr += 3;
            }
            break;

            case INDEX_op_lduw_T0_A0: /* [A0] -> T0 无符号,2字节 */
            {
                extern void op_lduw_T0_A0();
                memcpy(gen_code_ptr, &op_lduw_T0_A0, 3);
                gen_code_ptr += 3;
            }
            break;
```



```c
void OPPROTO op_ldsb_T0_A0(void) /* [A0] -> T0 有符号,1个字节 */
{
    T0 = ldsb((int8_t *)A0);
}

void OPPROTO op_lduw_T0_A0(void) /* [A0] -> T0 无符号,2个字节 */
{
    T0 = lduw((uint8_t *)A0);
}
```

## st

存值

```c
            case INDEX_op_stb_T0_A0: /* T0 -> [A0],1字节 */
            {
                extern void op_stb_T0_A0();
                memcpy(gen_code_ptr, &op_stb_T0_A0, 2);
                gen_code_ptr += 2;
            }
            break;

            case INDEX_op_stw_T0_A0: /* T0 -> [A0], 2字节 */
            {
                extern void op_stw_T0_A0();
                memcpy(gen_code_ptr, &op_stw_T0_A0, 3);
                gen_code_ptr += 3;
            }
            break;
```



```c
void OPPROTO op_stb_T0_A0(void)
{
    stb((uint8_t *)A0, T0);
}

void OPPROTO op_stw_T0_A0(void)
{
    stw((uint8_t *)A0, T0);
}
```



```c
static inline void stb(void *ptr, int v)
{
    *(uint8_t *)ptr = v;
}

static inline void stw(void *ptr, int v)
{
    *(uint16_t *)ptr = v;
}
```



## add_bit



```c
            case INDEX_op_add_bitw_A0_T1:
            {
                extern void op_add_bitw_A0_T1();
                memcpy(gen_code_ptr, &op_add_bitw_A0_T1, 8);
                gen_code_ptr += 8;
            }
            break;
```



```c
void OPPROTO op_add_bitw_A0_T1(void)
{
    A0 += ((int32_t)T1 >> 4) << 1;
}
```



## jmp

跳转指令.

```c
            case INDEX_op_jmp_T0:
            {
                extern void op_jmp_T0();
                memcpy(gen_code_ptr, &op_jmp_T0, 3);
                gen_code_ptr += 3;
            }
            break;

            case INDEX_op_jmp_im:
            {
                long param1;
                extern void op_jmp_im();
                memcpy(gen_code_ptr, &op_jmp_im, 7);
                param1 = *opparam_ptr++;
                *(uint32_t *)(gen_code_ptr + 3) = param1 + 0;
                gen_code_ptr += 7;
            }
            break;
```



```c
void OPPROTO op_jmp_T0(void) /* 跳转到T0指向的地址 */
{
    EIP = T0;
}

void OPPROTO op_jmp_im(void) /* 直接跳转到立即数指示的地址 */
{
    EIP = PARAM1;
}
```

