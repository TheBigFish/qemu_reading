本文将会简要介绍tcg的实现流程,包括它所使用的数据结构,变量等.但是tcg的实现中包含了大量的技术细节,这些细节由于个人精力原因,不能一一讲述,这些细节,读者愿意花费精力的话,在了解了本文所描述的内容之后,想必读起来难度也不会太大.

本文将以x86为实例.

# tcg的初始化

## TCGContext的初始化

qemu中定义了结构体TCGOpDef,这个结构体的实例用于记录中间码的相关信息,包括输入参数个数,输出参数个数等.

TCGArgConstraint结构体的实例主要用于描述每个参数的信息,比如说,可以使用哪些寄存器等.

```c
// tcg.h

typedef uint32_t TCGRegSet;
/* 参数限制 */
typedef struct TCGArgConstraint {
    uint16_t ct;
    uint8_t alias_index;
    union {
        TCGRegSet regs; /* 参数可用的寄存器 */
    } u;
} TCGArgConstraint;

/* 操作定义 */
typedef struct TCGOpDef {
    const char *name;
    uint8_t nb_oargs; /* 输出参数的个数 */
    uint8_t nb_iargs; /* 输入参数的个数 */
    uint8_t nb_cargs; /* 常量参数的个数 */
    uint8_t nb_args; /* 总参数的个数 */
    uint8_t flags;
    uint16_t copy_size;
    TCGArgConstraint *args_ct;
    int *sorted_args;
} TCGOpDef;
```

qemu中定义了一个非常重要的静态数组tcg_op_defs,这个数组主要就是用来表述qemu中特有的中间码,qemu使用了宏的方式来定义数组.

```c
// tcg.c
static TCGOpDef tcg_op_defs[] = {
#define DEF(s, n, copy_size) { #s, 0, 0, n, n, 0, copy_size },
#define DEF2(s, iargs, oargs, cargs, flags) { #s, iargs, oargs, cargs, iargs + oargs + cargs, flags, 0 },
#include "tcg-opc.h"
#undef DEF
#undef DEF2
};

// tcg-opc.h
/* predefined ops */
DEF2(end, 0, 0, 0, 0) /* must be kept first */
DEF2(nop, 0, 0, 0, 0)
DEF2(nop1, 0, 0, 1, 0)
DEF2(nop2, 0, 0, 2, 0)
DEF2(nop3, 0, 0, 3, 0)
DEF2(nopn, 0, 0, 1, 0) /* variable number of parameters */

DEF2(discard, 1, 0, 0, 0)

DEF2(set_label, 0, 0, 1, 0)
DEF2(call, 0, 1, 2, TCG_OPF_SIDE_EFFECTS) /* variable number of parameters */
DEF2(jmp, 0, 1, 0, TCG_OPF_BB_END | TCG_OPF_SIDE_EFFECTS)
DEF2(br, 0, 0, 1, TCG_OPF_BB_END | TCG_OPF_SIDE_EFFECTS)

DEF2(mov_i32, 1, 1, 0, 0)
DEF2(movi_i32, 1, 0, 1, 0)
/* load/store */
DEF2(ld8u_i32, 1, 1, 1, 0)
DEF2(ld8s_i32, 1, 1, 1, 0)
DEF2(ld16u_i32, 1, 1, 1, 0)
DEF2(ld16s_i32, 1, 1, 1, 0)
DEF2(ld_i32, 1, 1, 1, 0)
DEF2(st8_i32, 0, 2, 1, TCG_OPF_SIDE_EFFECTS)
DEF2(st16_i32, 0, 2, 1, TCG_OPF_SIDE_EFFECTS)
DEF2(st_i32, 0, 2, 1, TCG_OPF_SIDE_EFFECTS)
/* arith */
DEF2(add_i32, 1, 2, 0, 0)
DEF2(sub_i32, 1, 2, 0, 0)
DEF2(mul_i32, 1, 2, 0, 0)

// ...
DEF2(and_i32, 1, 2, 0, 0)
DEF2(or_i32, 1, 2, 0, 0)
DEF2(xor_i32, 1, 2, 0, 0)
// ...

DEF2(brcond_i32, 0, 2, 2, TCG_OPF_BB_END | TCG_OPF_SIDE_EFFECTS)
```

结构体TCGContext的实例主要用于代码翻译,用于记录代码翻译中的上下文信息.

```c
typedef struct TCGContext TCGContext;

struct TCGContext {
    uint8_t *pool_cur;
    uint8_t *pool_end;
    TCGPool *pool_first;
    TCGPool *pool_current;
    TCGLabel *labels;
    int nb_labels;
    /* temps给我的感觉更像是一个缓存池 */
    TCGTemp *temps; /* globals first, temps after */
    int nb_globals; /* 全局变量的个数 */
    int nb_temps; /* 临时变量的个数 */
    /* index of free temps, -1 if none */
    int first_free_temp[TCG_TYPE_COUNT * 2]; 

    /* goto_tb support */
    uint8_t *code_buf;
    unsigned long *tb_next;
    uint16_t *tb_next_offset;
    uint16_t *tb_jmp_offset; /* != NULL if USE_DIRECT_JUMP */

    /* liveness analysis */
    uint16_t *op_dead_iargs; /* for each operation, each bit tells if the
                                corresponding input argument is dead */
    
    /* tells in which temporary a given register is. It does not take
       into account fixed registers */
    int reg_to_temp[TCG_TARGET_NB_REGS];
    TCGRegSet reserved_regs;
    tcg_target_long current_frame_offset;
    tcg_target_long frame_start;
    tcg_target_long frame_end;
    int frame_reg;

    uint8_t *code_ptr;
    TCGTemp static_temps[TCG_MAX_TEMPS];
	// ...
};
```

`tcg_context_init` 函数用于初始化tcg context,目前来看,qemu中仅有TCGContext的一个实例tcg_ctx.

大致的调用流程为 `main -> cpu_exec_init_all -> cpu_gen_init -> tcg_context_init`.

```c
// exec.c
uint8_t code_gen_prologue[1024] code_gen_section;

// translate-all.c
/* code generation context */
TCGContext tcg_ctx; /* 全局唯一的变量 */

//tcg.c
/* 初始化TCGContext
 * @param s 待初始化的tcg context
 */
void tcg_context_init(TCGContext *s)
{
    int op, total_args, n;
    TCGOpDef *def;
    TCGArgConstraint *args_ct;
    int *sorted_args;
    memset(s, 0, sizeof(*s));
    s->temps = s->static_temps; /* 临时变量 */
    s->nb_globals = 0;
    
    /* Count total number of arguments and allocate the corresponding space */
    total_args = 0;
    for(op = 0; op < NB_OPS; op++) {
        def = &tcg_op_defs[op];
        n = def->nb_iargs + def->nb_oargs;
        total_args += n; /* 总参数的个数 */
    }
    args_ct = qemu_malloc(sizeof(TCGArgConstraint) * total_args);
    sorted_args = qemu_malloc(sizeof(int) * total_args);

    for(op = 0; op < NB_OPS; op++) {
        def = &tcg_op_defs[op];
        def->args_ct = args_ct;
        def->sorted_args = sorted_args;
        n = def->nb_iargs + def->nb_oargs;
        sorted_args += n;
        args_ct += n;
    } 
    tcg_target_init(s);
    /* init global prologue and epilogue */
    s->code_buf = code_gen_prologue;
    s->code_ptr = s->code_buf;
    tcg_target_qemu_prologue(s); /* 前置指令生成 */
    flush_icache_range((unsigned long)s->code_buf, (unsigned long)s->code_ptr);
}

void cpu_gen_init(void)
{
    tcg_context_init(&tcg_ctx);
    tcg_set_frame(&tcg_ctx, TCG_AREG0, offsetof(CPUState, temp_buf),
                  CPU_TEMP_BUF_NLONGS * sizeof(long));
}
```

`tcg_context_init` 函数中,值得说一下的是两个函数,一个是 `tcg_target_init`,这个函数和平台相关,以x86为例,主要用于记录变量可以使用的寄存器,以及需要保留的寄存器不能分配给变量使用的寄存器,为之后的代码翻译做准备.

另外一个是 `tcg_target_qemu_prologue`,这个函数生成一些前置指令,方便qemu调用翻译出来的指令.

### tcg_target_init

```c
// tcg.h
#define TCG_TYPE_I32 0
#define TCG_TYPE_I64 1

// tcg.c
static TCGRegSet tcg_target_available_regs[2];
static TCGRegSet tcg_target_call_clobber_regs;
#include "tcg-target.c"

// tcg-target.c
/* 初始化 */
void tcg_target_init(TCGContext *s)
{
    /* fail safe */
    if ((1 << CPU_TLB_ENTRY_BITS) != sizeof(CPUTLBEntry))
        tcg_abort();

    tcg_regset_set32(tcg_target_available_regs[TCG_TYPE_I32], 0, 0xffff);
    tcg_regset_set32(tcg_target_available_regs[TCG_TYPE_I64], 0, 0xffff);
    tcg_regset_set32(tcg_target_call_clobber_regs, 0,
                     (1 << TCG_REG_RDI) | 
                     (1 << TCG_REG_RSI) | 
                     (1 << TCG_REG_RDX) |
                     (1 << TCG_REG_RCX) |
                     (1 << TCG_REG_R8) |
                     (1 << TCG_REG_R9) |
                     (1 << TCG_REG_RAX) |
                     (1 << TCG_REG_R10) |
                     (1 << TCG_REG_R11));
    
    tcg_regset_clear(s->reserved_regs);
    tcg_regset_set_reg(s->reserved_regs, TCG_REG_RSP); /* RSP寄存器要保留 */
    tcg_add_target_add_op_defs(x86_64_op_defs);
}
```

`tcg_add_target_add_op_defs` 函数用于描述中间码转换成目标码,应当遵守的规则,注意,这里的指令和平台相关,所以被放在了tcg-target.c文件之中.

我们先来看一下数组x86_64_op_defs,这个数组的每个元素代表一条中间指令,第2个元素是一个数组,限定了中间指令的行为,比如说r代表应当加载到寄存器等.

```c
// tcg.h
typedef struct TCGTargetOpDef {
    int op;
    const char *args_ct_str[TCG_MAX_OP_ARGS];
} TCGTargetOpDef;

// tcg-target.c
static const TCGTargetOpDef x86_64_op_defs[] = {
    { INDEX_op_exit_tb, { } },
    { INDEX_op_goto_tb, { } },
    { INDEX_op_call, { "ri" } }, /* XXX: might need a specific constant constraint */
    { INDEX_op_jmp, { "ri" } }, /* XXX: might need a specific constant constraint */
    { INDEX_op_br, { } },
	// ...

    { INDEX_op_add_i32, { "r", "0", "ri" } },
    { INDEX_op_mul_i32, { "r", "0", "ri" } },
    { INDEX_op_div2_i32, { "a", "d", "0", "1", "r" } },
    { INDEX_op_sub_i32, { "r", "0", "ri" } },
    { INDEX_op_and_i32, { "r", "0", "ri" } },
    { INDEX_op_or_i32, { "r", "0", "ri" } },
    { INDEX_op_xor_i32, { "r", "0", "ri" } },
    { INDEX_op_shl_i32, { "r", "0", "ci" } },
    { INDEX_op_brcond_i32, { "r", "ri" } },
    // ...
    { INDEX_op_qemu_st16, { "L", "L" } },
    { INDEX_op_qemu_st32, { "L", "L" } },

    { -1 },
};
```

`tcg_add_target_add_op_defs` 用于解析上面的数组信息,最终完成tcg_op_defs数组的初始化.

```c
// tcg.c
/* parse target specific constraints */
static int target_parse_constraint(TCGArgConstraint *ct, const char **pct_str)
{
    const char *ct_str;
    ct_str = *pct_str;
    switch(ct_str[0]) {
    case 'a':
        ct->ct |= TCG_CT_REG; /* 限制只能使用寄存器rax */
        tcg_regset_set_reg(ct->u.regs, TCG_REG_RAX); /* rax */
        break;
	// ...
    case 'q':
        ct->ct |= TCG_CT_REG;
        tcg_regset_set32(ct->u.regs, 0, 0xf);
        break;
    case 'r':
        ct->ct |= TCG_CT_REG; /* 变量应当放在寄存器中 */
        tcg_regset_set32(ct->u.regs, 0, 0xffff); /* 可以使用任意的寄存器 */
        break;
    case 'L': /* qemu_ld/st constraint */
        ct->ct |= TCG_CT_REG;
        tcg_regset_set32(ct->u.regs, 0, 0xffff);
        tcg_regset_reset_reg(ct->u.regs, TCG_REG_RSI);
        tcg_regset_reset_reg(ct->u.regs, TCG_REG_RDI);
        break;
    case 'e':
        ct->ct |= TCG_CT_CONST_S32;
        break;
    case 'Z':
        ct->ct |= TCG_CT_CONST_U32;
        break;
    default:
        return -1;
    }
    ct_str++;
    *pct_str = ct_str;
    return 0;
}

/* 解析语法,生成def */
void tcg_add_target_add_op_defs(const TCGTargetOpDef *tdefs)
{
    int op;
    TCGOpDef *def;
    const char *ct_str;
    int i, nb_args;

    for(;;) {
        if (tdefs->op < 0) /* tdefs是数组最后一个元素 */
            break;
        op = tdefs->op;
        def = &tcg_op_defs[op]; /* 注意数组tcg_op_defs */
        nb_args = def->nb_iargs + def->nb_oargs; /* 参数的个数 */
        for(i = 0; i < nb_args; i++) {
            ct_str = tdefs->args_ct_str[i]; /* opdef对于每一个参数都有限定 */
            tcg_regset_clear(def->args_ct[i].u.regs);
            def->args_ct[i].ct = 0;
            if (ct_str[0] >= '0' && ct_str[0] <= '9') { /* 数字 */
                int oarg;
                oarg = ct_str[0] - '0';
                assert(def->args_ct[oarg].ct & TCG_CT_REG);
                /* TCG_CT_ALIAS is for the output arguments. The input
                   argument is tagged with TCG_CT_IALIAS. */
                def->args_ct[i] = def->args_ct[oarg]; /* 第i个参数是第oarg个参数的别名 */
                def->args_ct[oarg].ct = TCG_CT_ALIAS; 
                def->args_ct[oarg].alias_index = i;
                def->args_ct[i].ct |= TCG_CT_IALIAS; /* IALIAS -- is alias? */
                def->args_ct[i].alias_index = oarg;
            } else {
                for(;;) {
                    if (*ct_str == '\0')
                        break;
                    switch(*ct_str) {
                    case 'i':
                        def->args_ct[i].ct |= TCG_CT_CONST; /* 限定常数 */
                        ct_str++;
                        break;
                    default:
                        if (target_parse_constraint(&def->args_ct[i], &ct_str) < 0) {
                            fprintf(stderr, "Invalid constraint '%s' for arg %d of operation '%s'\n",
                                    ct_str, i, def->name);
                            exit(1);
                        }
                    }
                }
            }
        }

        /* sort the constraints (XXX: this is just an heuristic) */
        sort_constraints(def, 0, def->nb_oargs);
        sort_constraints(def, def->nb_oargs, def->nb_iargs);
        tdefs++;
    }
}
```

`sort_constraints` 用于对参数进行排序.排序规则的定义很简单,如果一个参数可以使用的寄存器越多,那么它的优先级就越高.

在上面的函数中,先对输入参数进行排序,然后对输出参数进行排序.

```c
// tcg.c
/* we give more priority to constraints with less registers 
 * 计算优先级, 寄存器越少,那么优先级越低?
 */
static int get_constraint_priority(const TCGOpDef *def, int k)
{
    const TCGArgConstraint *arg_ct;

    int i, n;
    arg_ct = &def->args_ct[k];
    if (arg_ct->ct & TCG_CT_ALIAS) {
        /* an alias is equivalent to a single register */
        n = 1;
    } else {
        if (!(arg_ct->ct & TCG_CT_REG))
            return 0;
        n = 0;
        for(i = 0; i < TCG_TARGET_NB_REGS; i++) { /* 可以使用的寄存器越多,那么优先级越高 */
            if (tcg_regset_test_reg(arg_ct->u.regs, i))
                n++;
        }
    }
    return TCG_TARGET_NB_REGS - n + 1;
}
/* sort from highest priority to lowest
 * 从最高优先级->最低优先级 排序
 */
static void sort_constraints(TCGOpDef *def, int start, int n)
{
    int i, j, p1, p2, tmp;

    for(i = 0; i < n; i++)
        def->sorted_args[start + i] = start + i;
    if (n <= 1)
        return;
    for(i = 0; i < n - 1; i++) {
        for(j = i + 1; j < n; j++) {
            p1 = get_constraint_priority(def, def->sorted_args[start + i]);
            p2 = get_constraint_priority(def, def->sorted_args[start + j]);
            if (p1 < p2) {
                tmp = def->sorted_args[start + i];
                def->sorted_args[start + i] = def->sorted_args[start + j];
                def->sorted_args[start + j] = tmp;
            }
        }
    }
}
```

### tcg_target_qemu_prologue

qemu的代码翻译以TraslationBlock为单位.为了实现简单,我们自然希望,执行一个TranslationBlock中翻译的代码,就就像是执行一个函数一样.

这也是为什么qemu在翻译原始码之前,总要先生成一段prologue,以及一段epilogue的原因所在.

prologue是用汇编实现了一个函数,函数的形式类似于:

```c
void * code_gen_prologue(void *tb_ptr);
```

它接收一个参数,prologue先保存被调用者应当保存的寄存器,然后调整堆栈寄存器(ESP),跳转到参数1(RDI)指定的地址去执行指令.

epilogue类似于函数的返回,它还原那些应当被调用者保存的寄存器的值,调整堆栈寄存器(ESP),然后返回,返回值是模拟cpu应当执行的下一条指令地址.

请特别注意静态变量tb_ret_addr,这个值在代码翻译中有很大的作用,这个我们稍后再讲.

``` c
// tcg-target.c
static uint8_t *tb_ret_addr;

static int tcg_target_callee_save_regs[] = {
    /*    TCG_REG_EBP, */ /* currently used for the global env, so no
                             need to save */
    TCG_REG_EBX,
    TCG_REG_ESI,
    TCG_REG_EDI,
};

/* Generate global QEMU prologue and epilogue code */
void tcg_target_qemu_prologue(TCGContext *s)
{
    int i, frame_size, push_size, stack_addend;
    
    /* TB prologue -- 前奏 */
    /* save all callee saved registers */
    /* 保存所有应当被调用者保存的寄存器 */
    for(i = 0; i < ARRAY_SIZE(tcg_target_callee_save_regs); i++) {
        tcg_out_push(s, tcg_target_callee_save_regs[i]);
    }
    /* reserve some stack space */
    push_size = 4 + ARRAY_SIZE(tcg_target_callee_save_regs) * 4;
    frame_size = push_size + TCG_STATIC_CALL_ARGS_SIZE;
    frame_size = (frame_size + TCG_TARGET_STACK_ALIGN - 1) & 
        ~(TCG_TARGET_STACK_ALIGN - 1);
    stack_addend = frame_size - push_size;
    tcg_out_addi(s, TCG_REG_ESP, -stack_addend);
	/* 跳转到rdi寄存器保存的地址去执行 */
    tcg_out_modrm(s, 0xff, 4, TCG_REG_RDI); /* jmp *%rdi */
    
    /* TB epilogue -- 尾声 */
    tb_ret_addr = s->code_ptr; /* s->code_ptr表示当前指令的位置,每生成一条指令,code_ptr都会后移 */
    tcg_out_addi(s, TCG_REG_ESP, stack_addend); /* 还原esp寄存器 */
    for(i = ARRAY_SIZE(tcg_target_callee_save_regs) - 1; i >= 0; i--) {
        tcg_out_pop(s, tcg_target_callee_save_regs[i]); /* 参数出栈 */
    }
    tcg_out8(s, 0xc3); /* ret */
}
```

## 变量的初始化

qemu模拟的cpu里面,还有一些比较特殊的变量,在qemu初始化cpu的时候,也会顺带初始化这些变量.

大致的流程是`pc_init_pci -> pc_init1 -> cpu_x86_init`.

```c
CPUX86State *cpu_x86_init(const char *cpu_model)
{
    CPUX86State *env;
    static int inited;

    env = qemu_mallocz(sizeof(CPUX86State));
    cpu_exec_init(env);
    env->cpu_model_str = cpu_model;

    /* init various static tables */
    if (!inited) {
        inited = 1;
        optimize_flags_init();
    }
    if (cpu_x86_register(env, cpu_model) < 0) {
        cpu_x86_close(env);
        return NULL;
    }
    cpu_reset(env);
	// ...
    return env;
}
```

`optimize_flags_init` 用于分配一些tcg全局变量,比如说cpu_cc_op,cpu_cc_src,cpu_cc_dst,这些变量在模拟cpu计算eflags的时候,用处颇大.如果感兴趣,可以看一下tcg译码2.

```c
//tcg.h
#define tcg_global_reg_new_ptr tcg_global_reg_new_i32
typedef struct
{
    int i32;
} TCGv_i32; /* 有符号的32位整数 */

// tcg.c
/* 分配一个全局的寄存器
 * @param reg 寄存器编号
 */
static inline int tcg_global_reg_new_internal(TCGType type, int reg, const char *name)
{
    TCGContext *s = &tcg_ctx; /* 使用全局唯一的TCGContext的实例 */
    TCGTemp *ts;
    int idx;
    if (tcg_regset_test_reg(s->reserved_regs, reg)) /* 不能使用保留的寄存器 */
        tcg_abort();
    idx = s->nb_globals;
    tcg_temp_alloc(s, s->nb_globals + 1);
    ts = &s->temps[s->nb_globals];
    ts->base_type = type;
    ts->type = type; /* 记录下类型 */
    ts->fixed_reg = 1; /* 采用固定的寄存器 */
    ts->reg = reg;
    ts->name = name;
    s->nb_globals++;
    tcg_regset_set_reg(s->reserved_regs, reg);
    return idx;
}

TCGv_i32 tcg_global_reg_new_i32(int reg, const char *name)
{
    int idx;
    idx = tcg_global_reg_new_internal(TCG_TYPE_I32, reg, name);
    return MAKE_TCGV_I32(idx);
}

/* 分配一个全局的内存变量 */
static inline int tcg_global_mem_new_internal(TCGType type, int reg,
                                              tcg_target_long offset,
                                              const char *name)
{
    TCGContext *s = &tcg_ctx;
    TCGTemp *ts;
    int idx;
    idx = s->nb_globals;
    tcg_temp_alloc(s, s->nb_globals + 1);
    ts = &s->temps[s->nb_globals];
    ts->base_type = type;
    ts->type = type;
    ts->fixed_reg = 0;
    ts->mem_allocated = 1;
    ts->mem_reg = reg;
    ts->mem_offset = offset;
    ts->name = name;
    s->nb_globals++;
    return idx;
}

TCGv_i32 tcg_global_mem_new_i32(int reg, tcg_target_long offset,
                                const char *name)
{
    int idx;
    idx = tcg_global_mem_new_internal(TCG_TYPE_I32, reg, offset, name);
    return MAKE_TCGV_I32(idx);
}

// tcg-target.h
#define TCG_AREG0 TCG_REG_EBP
#define TCG_AREG1 TCG_REG_EBX
#define TCG_AREG2 TCG_REG_ESI
#define TCG_AREG3 TCG_REG_EDI

// translate.c
/* global register indexes 
 * 全局寄存器索引
 */
static TCGv_ptr cpu_env;
/* cpu_A0应该是一个内存变量 */
static TCGv cpu_A0, cpu_cc_src, cpu_cc_dst, cpu_cc_tmp;
static TCGv_i32 cpu_cc_op;

void optimize_flags_init(void)
{
    cpu_env = tcg_global_reg_new_ptr(TCG_AREG0, "env"); /* 分配一个全局的指针 */
    cpu_cc_op = tcg_global_mem_new_i32(TCG_AREG0, offsetof(CPUState, cc_op), "cc_op");
    /* 这里获取的是env->cc_src,也就是直接修改CPUState实例中字段的值 */
    cpu_cc_src = tcg_global_mem_new(TCG_AREG0, offsetof(CPUState, cc_src), "cc_src");
    cpu_cc_dst = tcg_global_mem_new(TCG_AREG0, offsetof(CPUState, cc_dst), "cc_dst");
    cpu_cc_tmp = tcg_global_mem_new(TCG_AREG0, offsetof(CPUState, cc_tmp), "cc_tmp");
	// ...
}
```

# tcg实现流程

qemu定义了一套中间码,tcg要做的第一步,就是将原始码翻译成为中间码,一条原始码可能对应多条中间码.

qemu的指令翻译以TranslationBlock为单位.

```c
// exec.c
uint8_t *code_gen_ptr;

// exec-all.h
struct TranslationBlock {
    target_ulong pc;   /* simulated PC corresponding to this block (EIP + CS base) */
    target_ulong cs_base; /* CS base for this block */
    uint64_t flags; /* flags defining in which context the code was generated */
    uint16_t size;      /* size of target code for this block (1 <=
                           size <= TARGET_PAGE_SIZE) */
    uint16_t cflags;    /* compile flags */
#define CF_COUNT_MASK  0x7fff
#define CF_LAST_IO     0x8000 /* Last insn may be an IO access.  */
	/* 指向翻译过后的代码 */
    uint8_t *tc_ptr;    /* pointer to the translated code */
    /* next matching tb for physical address. */
    struct TranslationBlock *phys_hash_next;
    /* first and second physical page containing code. The lower bit
       of the pointer tells the index in page_next[] */
    struct TranslationBlock *page_next[2];
    target_ulong page_addr[2];

    /* the following data are used to directly call another TB from
       the code of this one. */
    uint16_t tb_next_offset[2]; /* offset of original jump target */
#ifdef USE_DIRECT_JUMP
    uint16_t tb_jmp_offset[4]; /* offset of jump instruction */
#else
    unsigned long tb_next[2]; /* address of jump generated code */
#endif
    /* list of TBs jumping to this one. This is a circular list using
       the two least significant bits of the pointers to tell what is
       the next pointer: 0 = jmp_next[0], 1 = jmp_next[1], 2 =
       jmp_first */
    struct TranslationBlock *jmp_next[2];
    struct TranslationBlock *jmp_first;
    uint32_t icount; /* 指令条数 */
};

// tcg.c
/* 指令生成
 * @param pc 模拟的cpu当前要执行的下一条指令的地址
 * @param cs_base 模拟的cpu的cs段地址
 */
TranslationBlock *tb_gen_code(CPUState *env,
                              target_ulong pc, 
                              target_ulong cs_base,
                              int flags, int cflags)
{
    TranslationBlock *tb;
    uint8_t *tc_ptr;
    target_ulong phys_pc, phys_page2, virt_page2;
    int code_gen_size;

    phys_pc = get_phys_addr_code(env, pc);
    tb = tb_alloc(pc); /* 分配一个TranslationBlock */
    if (!tb) {
        /* flush must be done */
        tb_flush(env);
        /* cannot fail at this point */
        tb = tb_alloc(pc);
        /* Don't forget to invalidate previous TB info.  */
        tb_invalidated_flag = 1;
    }
    tc_ptr = code_gen_ptr;
    tb->tc_ptr = tc_ptr;
    tb->cs_base = cs_base;
    tb->flags = flags;
    tb->cflags = cflags;
    cpu_gen_code(env, tb, &code_gen_size); /* 指令生成 */
    code_gen_ptr = (void *)(((unsigned long)code_gen_ptr + code_gen_size + CODE_GEN_ALIGN - 1) 
                            & ~(CODE_GEN_ALIGN - 1));

    /* check next page if needed */
    virt_page2 = (pc + tb->size - 1) & TARGET_PAGE_MASK;
    phys_page2 = -1;
    if ((pc & TARGET_PAGE_MASK) != virt_page2) {
        phys_page2 = get_phys_addr_code(env, virt_page2);
    }
    tb_link_phys(tb, phys_pc, phys_page2);
    return tb;
}
```

`cpu_gen_code` 用于指令的翻译.

```c
// translate-all.c
uint8_t gen_opc_instr_start[OPC_BUF_SIZE];
target_ulong gen_opc_pc[OPC_BUF_SIZE];
uint16_t gen_opc_icount[OPC_BUF_SIZE];
uint16_t gen_opc_buf[OPC_BUF_SIZE];

// tcg.c
uint16_t *gen_opc_ptr;

/* 初始化TCG上下文
 * @param s TCG上下文
 */
void tcg_func_start(TCGContext *s)
{
    int i;
    tcg_pool_reset(s); /* tcg使用了一个内存池 */
    s->nb_temps = s->nb_globals; /* 此时仅仅只有全局变量 */
    for(i = 0; i < (TCG_TYPE_COUNT * 2); i++)
        s->first_free_temp[i] = -1;
    s->labels = tcg_malloc(sizeof(TCGLabel) * TCG_MAX_LABELS);
    s->nb_labels = 0;
    s->current_frame_offset = s->frame_start;
    gen_opc_ptr = gen_opc_buf; /* gen_opc_ptr这个指针指向全局数组gen_opc_buf */
    gen_opparam_ptr = gen_opparam_buf;
}

/* 中间指令生成 */
void gen_intermediate_code(CPUState *env, TranslationBlock *tb)
{
    gen_intermediate_code_internal(env, tb, 0);
}

// translate-all.c
/* 如果第一条指令无效,那么返回非0
 * @param env cpu实例的指针
 */
int cpu_gen_code(CPUState *env, TranslationBlock *tb, int *gen_code_size_ptr)
{
    TCGContext *s = &tcg_ctx;
    uint8_t *gen_code_buf;
    int gen_code_size;

    tcg_func_start(s);
    gen_intermediate_code(env, tb); /* 完成原始码->中间码的翻译 */
    /* generate machine code */
    gen_code_buf = tb->tc_ptr;
    tb->tb_next_offset[0] = 0xffff;
    tb->tb_next_offset[1] = 0xffff;
    s->tb_next_offset = tb->tb_next_offset;

    s->tb_jmp_offset = tb->tb_jmp_offset;
    s->tb_next = NULL;
    /* the following two entries are optional (only used for string ops) */
    tb->tb_jmp_offset[2] = 0xffff;
    tb->tb_jmp_offset[3] = 0xffff;

    gen_code_size = tcg_gen_code(s, gen_code_buf); /* 完成中间码 -> 目标码的翻译 */
    *gen_code_size_ptr = gen_code_size;
    return 0;
}
```

## 原始码 -> 中间码

`gen_intermediate_code_internal` 完成原始码到中间码的转换.

```c
// translate.c
/* 指令上下文 */
typedef struct DisasContext {
    /* current insn context */
    int override; /* -1 if no override */
    int prefix;
    int aflag, dflag;
    target_ulong pc; /* pc = eip + cs_base */
    int is_jmp; /* 1 = means jump (stop translation), 2 means CPU
                   static state change (stop translation) */
    /* current block context */
    target_ulong cs_base; /* base of CS segment */
    int pe;     /* protected mode -- 保护模式 */
    int code32; /* 32 bit code segment */
    int ss32;   /* 32 bit stack segment */
    int cc_op;  /* current CC operation */
    int addseg; /* non zero if either DS/ES/SS have a non zero base */
    int f_st;   /* currently unused */
    int vm86;   /* vm86 mode */
    int cpl;
    int iopl;
    int tf;     /* TF cpu flag */
    int singlestep_enabled; /* "hardware" single step enabled */
    int jmp_opt; /* use direct block chaining for direct jumps */
    int mem_index; /* select memory access functions */
    uint64_t flags; /* all execution flags */
    struct TranslationBlock *tb;
    int popl_esp_hack; /* for correct popl with esp base handling */
    int rip_offset; /* only used in x86_64, but left for simplicity */
	// ...
} DisasContext;

// translate-all.c
/* 这几个数组主要记录原始码和中间码的对应关系 */
uint8_t gen_opc_instr_start[OPC_BUF_SIZE];
target_ulong gen_opc_pc[OPC_BUF_SIZE];
uint16_t gen_opc_icount[OPC_BUF_SIZE];
uint16_t gen_opc_buf[OPC_BUF_SIZE];

// tcg.c
uint16_t *gen_opc_ptr;

// translate.c
/* 中间指令生成,如果search_pc为TRUE,那么为每一条中间指令生成PC 信息
 * @param env cpu实例指针
 * @param tb
 */
static inline void gen_intermediate_code_internal(CPUState *env,
                                                  TranslationBlock *tb,
                                                  int search_pc)
{
    DisasContext dc1, *dc = &dc1;
    target_ulong pc_ptr;
    uint16_t *gen_opc_end;
    CPUBreakpoint *bp;
    int j, lj, cflags;
    uint64_t flags;
    target_ulong pc_start;
    target_ulong cs_base;
    int num_insns;
    int max_insns;

    /* generate intermediate code */
    pc_start = tb->pc;
    cs_base = tb->cs_base; /* 代码段 */
    flags = tb->flags; /* cpu的 */
    cflags = tb->cflags;

    dc->pe = (flags >> HF_PE_SHIFT) & 1;
    dc->code32 = (flags >> HF_CS32_SHIFT) & 1;
    dc->ss32 = (flags >> HF_SS32_SHIFT) & 1;
    dc->addseg = (flags >> HF_ADDSEG_SHIFT) & 1;
    dc->f_st = 0;
    dc->vm86 = (flags >> VM_SHIFT) & 1;
    dc->cpl = (flags >> HF_CPL_SHIFT) & 3;
    dc->iopl = (flags >> IOPL_SHIFT) & 3;
    dc->tf = (flags >> TF_SHIFT) & 1;
    dc->singlestep_enabled = env->singlestep_enabled; /* 单步执行 */
    dc->cc_op = CC_OP_DYNAMIC;
    dc->cs_base = cs_base;
    dc->tb = tb;
    dc->popl_esp_hack = 0;
    /* select memory access functions */
    dc->mem_index = 0;
    if (flags & HF_SOFTMMU_MASK) {
        if (dc->cpl == 3)
            dc->mem_index = 2 * 4;
        else
            dc->mem_index = 1 * 4;
    }
	// ...
    dc->flags = flags;
    dc->jmp_opt = !(dc->tf || env->singlestep_enabled ||
                    (flags & HF_INHIBIT_IRQ_MASK)
                    || (flags & HF_SOFTMMU_MASK));

	/* 分配一些临时变量 */
    cpu_T[0] = tcg_temp_new();
    cpu_T[1] = tcg_temp_new();
    cpu_A0 = tcg_temp_new();
    cpu_T3 = tcg_temp_new();

    cpu_tmp0 = tcg_temp_new();
    cpu_tmp1_i64 = tcg_temp_new_i64();
    cpu_tmp2_i32 = tcg_temp_new_i32();
    cpu_tmp3_i32 = tcg_temp_new_i32();
    cpu_tmp4 = tcg_temp_new();
    cpu_tmp5 = tcg_temp_new();
    cpu_tmp6 = tcg_temp_new();
    cpu_ptr0 = tcg_temp_new_ptr();
    cpu_ptr1 = tcg_temp_new_ptr();

    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;
    dc->is_jmp = DISAS_NEXT;
    pc_ptr = pc_start;
    lj = -1;
    num_insns = 0; /* 已经生成的指令的条数 */
    max_insns = tb->cflags & CF_COUNT_MASK;
    if (max_insns == 0)
        max_insns = CF_COUNT_MASK;

    gen_icount_start();
    for(;;) {
		// ...
        if (search_pc) {
            /* gen_opc_ptr指向下一条中间指令 
             * j表示上一条原始码对应的中间码的条数
             */
            j = gen_opc_ptr - gen_opc_buf;
            if (lj < j) {
                lj++;
                while (lj < j)
                    gen_opc_instr_start[lj++] = 0;
            }
            gen_opc_pc[lj] = pc_ptr; /* 记录要翻译的下一条原始码的地址 */
            gen_opc_cc_op[lj] = dc->cc_op;
            gen_opc_instr_start[lj] = 1; /* 表示从lj的位置开始,开始翻译下一条原始码 */
            gen_opc_icount[lj] = num_insns; /* 记录已经生成的指令的条数 */
        }
        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))
            gen_io_start();
		/* pc_ptr指向待翻译的原始码 */
        pc_ptr = disas_insn(dc, pc_ptr); /* 指令翻译,每次翻译1条指令 */
        num_insns++; /* 翻译的原始码的数目+1 */
        /* stop translation if indicated */
        if (dc->is_jmp)
            break;
        /* if irq were inhibited with HF_INHIBIT_IRQ_MASK, we clear
           the flag and abort the translation to give the irqs a
           change to be happen */
        /* 如果单步模式开启,每翻译完一条原始码,就要产生一个异常 */
        if (dc->tf || dc->singlestep_enabled ||
            (flags & HF_INHIBIT_IRQ_MASK)) { /* 停止指令翻译 */
            gen_jmp_im(pc_ptr - dc->cs_base);
            gen_eob(dc);
            break;
        }
        /* if too long translation, stop generation too */
        if (gen_opc_ptr >= gen_opc_end ||
            (pc_ptr - pc_start) >= (TARGET_PAGE_SIZE - 32) ||
            num_insns >= max_insns) {
            gen_jmp_im(pc_ptr - dc->cs_base);
            gen_eob(dc);
            break;
        }
    }
    if (tb->cflags & CF_LAST_IO)
        gen_io_end();
    gen_icount_end(tb, num_insns);
    *gen_opc_ptr = INDEX_op_end; /* 最后生成一条end指令 */
    /* we don't forget to fill the last values */
    if (search_pc) {
        j = gen_opc_ptr - gen_opc_buf;
        lj++;
        while (lj <= j)
            gen_opc_instr_start[lj++] = 0;
    }

    if (!search_pc) {
        tb->size = pc_ptr - pc_start; /* 翻译原始指令的条数 */
        tb->icount = num_insns; /* 生成的中间指令数目 */
    }
}
```

偌大一个 `gen_intermediate_code_internal` 函数,其实就两件事情比较重要,第一件事情就是译码,也就是将原始指令翻译为中间指令.

第二件事情是做好收尾的工作,我们不可能无休无止地翻译原始码,翻译到了一定程度,要优雅地退出来,如何来处理退出,是非常重要的一件事情.

### 译码

`disas_insn` 用于将原始码翻译为中间码,相当复杂,毕竟要完整解析x86的指令.

当然,我这里是不可能对每条指令都面面俱到的,我仅仅只会涉及一些比较有意思的指令来讲述一下.整段代码,只需要把握住重点即可:

+ disas_insn将1条原始码,翻译成若干条中间码;
+ disas_insn翻译的中间码的效果和原始码等价.

```c
/* convert one instruction. s->is_jmp is set if the translation must
   be stopped. Return the next pc value */
/* 转换1条指令,如果翻译必须要停止的话,she这s->is_jmp
 * @param pc_start 原始码
 */
static target_ulong disas_insn(DisasContext *s, target_ulong pc_start)
{
    int b, prefixes, aflag, dflag;
    int shift, ot;
    int modrm, reg, rm, mod, reg_addr, op, opreg, offset_addr, val;
    target_ulong next_eip, tval;
    int rex_w, rex_r;

    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP)))
        tcg_gen_debug_insn_start(pc_start);
    s->pc = pc_start;
    prefixes = 0;
    aflag = s->code32;
    dflag = s->code32;
    s->override = -1;
    rex_w = -1;
    rex_r = 0;
    s->rip_offset = 0; /* for relative ip address */
 next_byte:
    b = ldub_code(s->pc); /* 加载指令 */
    s->pc++;
    /* check prefixes */
    {
		// ... 解析prefixes,忽略
    }

    s->prefix = prefixes;
    s->aflag = aflag;
    s->dflag = dflag;

    /* lock generation */
    if (prefixes & PREFIX_LOCK)
        gen_helper_lock();

    /* now check op code */
 reswitch: /* 检查op code,也就是操作码 */
    switch(b) {
    case 0x0f:
        /**************************/
        /* extended op code */
        b = ldub_code(s->pc++) | 0x100;
        goto reswitch;

        /**************************/
        /* arith & logic */
    case 0x00 ... 0x05:
    case 0x08 ... 0x0d:
    case 0x10 ... 0x15:
    case 0x18 ... 0x1d:
    case 0x20 ... 0x25:
    case 0x28 ... 0x2d:
    case 0x30 ... 0x35:
    case 0x38 ... 0x3d:
        {
            int op, f, val;
            op = (b >> 3) & 7; /* 操作符 */
            f = (b >> 1) & 3;

            if ((b & 1) == 0)
                ot = OT_BYTE; /* ot表示操作符长度 */
            else
                ot = dflag + OT_WORD;
            /* Ev 4字节内存
             * Gv 32位或者8位寄存器
             */
            switch(f) {
            case 0: /* OP Ev, Gv */
                modrm = ldub_code(s->pc++);
                reg = ((modrm >> 3) & 7) | rex_r; /* 读取reg字段 */
                mod = (modrm >> 6) & 3; /* 读取mod字段 */
                rm = (modrm & 7) | REX_B(s); /* 读取rm字段 */
                if (mod != 3) { /* mod为3表示寄存器间接寻址 */
                    gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);
                    opreg = OR_TMP0;
                } else if (op == OP_XORL && rm == reg) {
                xor_zero:
                    /* xor reg, reg optimisation */
                    gen_op_movl_T0_0(); /* T0 = 0 */
                    s->cc_op = CC_OP_LOGICB + ot;
                    gen_op_mov_reg_T0(ot, reg); /* reg = T0 */
                    gen_op_update1_cc(); /* cpu_cc_dst = T0 */
                    break;
                } else {
                    opreg = rm;
                }
                gen_op_mov_TN_reg(ot, 1, reg); /* T1 = reg */
                gen_op(s, op, ot, opreg);
                break;
            case 1: /* OP Gv, Ev */
                modrm = ldub_code(s->pc++);
                mod = (modrm >> 6) & 3;
                reg = ((modrm >> 3) & 7) | rex_r; /* 读取出使用的寄存器 */
                rm = (modrm & 7) | REX_B(s);
                if (mod != 3) { /* 寄存器间接寻址 */
                    gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);
                    gen_op_ld_T1_A0(ot + s->mem_index); /* 加载指令, T1 = read(A0) */
                } else if (op == OP_XORL && rm == reg) {
                    goto xor_zero;
                } else { /* 第2个操作数在rm指示的寄存器之中 */
                    gen_op_mov_TN_reg(ot, 1, rm); /* T1 = reg */
                }
                gen_op(s, op, ot, reg);
                break;
            case 2: /* OP A, Iv */
                val = insn_get(s, ot); /* 从指令中读取出立即数val,也就是Iv */
                gen_op_movl_T1_im(val); /* T1 = im */
                gen_op(s, op, ot, OR_EAX);
                break;
            }
        }
        break;
    case 0x82:
        if (CODE64(s))
            goto illegal_op;
    case 0x80: /* GRP1 */
    case 0x81:
    case 0x83:
        {
            int val;

            if ((b & 1) == 0)
                ot = OT_BYTE;
            else
                ot = dflag + OT_WORD;

            modrm = ldub_code(s->pc++);
            mod = (modrm >> 6) & 3;
            rm = (modrm & 7) | REX_B(s);
            op = (modrm >> 3) & 7;

            if (mod != 3) { /* 寄存器间接寻址 */
                if (b == 0x83)
                    s->rip_offset = 1;
                else
                    s->rip_offset = insn_const_size(ot);
                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr); /* 操作数加载到A0 */
                opreg = OR_TMP0;
            } else { /* 寄存器直接寻址 */
                opreg = rm;
            }

            switch(b) {
            default:
            case 0x80:
            case 0x81:
            case 0x82:
                val = insn_get(s, ot); /* 读取出立即数 */
                break;
            case 0x83:
                val = (int8_t)insn_get(s, OT_BYTE);
                break;
            }
            gen_op_movl_T1_im(val); /* 将立即数转移到T1寄存器 */
            gen_op(s, op, ot, opreg);
        }
        break;

        /**************************/
        /* inc, dec, and other misc arith */
    case 0x40 ... 0x47: /* inc Gv */
        ot = dflag ? OT_LONG : OT_WORD; /* 自增 */
        gen_inc(s, ot, OR_EAX + (b & 7), 1);
        break;
    case 0x48 ... 0x4f: /* dec Gv */
        ot = dflag ? OT_LONG : OT_WORD; /* 自减 */
        gen_inc(s, ot, OR_EAX + (b & 7), -1);
        break;
    case 0xf6: /* GRP3 */
    case 0xf7:
        if ((b & 1) == 0)
            ot = OT_BYTE;
        else
            ot = dflag + OT_WORD;

        modrm = ldub_code(s->pc++);
        mod = (modrm >> 6) & 3;
        rm = (modrm & 7) | REX_B(s);
        op = (modrm >> 3) & 7;
        if (mod != 3) {
            if (op == 0)
                s->rip_offset = insn_const_size(ot);
            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);
            gen_op_ld_T0_A0(ot + s->mem_index);
        } else {
            gen_op_mov_TN_reg(ot, 0, rm);
        }
        switch(op) {
        case 0: /* test */
            val = insn_get(s, ot); /* 读取立即数 */
            gen_op_movl_T1_im(val); /* 将立即数移动到T1之中 */
            gen_op_testl_T0_T1_cc();
            s->cc_op = CC_OP_LOGICB + ot;
            break;
        case 2: /* not */
            tcg_gen_not_tl(cpu_T[0], cpu_T[0]); /* T0 = ~ T0 */
            /* 将结果存储到源操作数中去 */
            if (mod != 3) { /* 寄存器间接寻址 */
                gen_op_st_T0_A0(ot + s->mem_index);
            } else { /* 寄存器直接寻址 */
                gen_op_mov_reg_T0(ot, rm);
            }
            break;
        case 3: /* neg */
            tcg_gen_neg_tl(cpu_T[0], cpu_T[0]); /* T0 = -T0 */
            /* 将结果存储到源操作数中去 */
            if (mod != 3) { /* 寄存器间接寻址 */
                gen_op_st_T0_A0(ot + s->mem_index);
            } else { /* 寄存器直接寻址 */
                gen_op_mov_reg_T0(ot, rm);
            }
            gen_op_update_neg_cc();
            s->cc_op = CC_OP_SUBB + ot;
            break;
        case 4: /* mul */
            switch(ot) {
            case OT_BYTE: /* 8bit乘法 */
                gen_op_mov_TN_reg(OT_BYTE, 1, R_EAX); /* T1 = EAX */
                tcg_gen_ext8u_tl(cpu_T[0], cpu_T[0]);
                tcg_gen_ext8u_tl(cpu_T[1], cpu_T[1]);
                /* XXX: use 32 bit mul which could be faster */
                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]); /* T0 = T0 * T1 */
                gen_op_mov_reg_T0(OT_WORD, R_EAX); /* EAX = T0 */
                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);
                tcg_gen_andi_tl(cpu_cc_src, cpu_T[0], 0xff00);
                s->cc_op = CC_OP_MULB;
                break;
            case OT_WORD:
                gen_op_mov_TN_reg(OT_WORD, 1, R_EAX);
                tcg_gen_ext16u_tl(cpu_T[0], cpu_T[0]); /* 首先扩展 */
                tcg_gen_ext16u_tl(cpu_T[1], cpu_T[1]);
                /* XXX: use 32 bit mul which could be faster */
                tcg_gen_mul_tl(cpu_T[0], cpu_T[0], cpu_T[1]); /* T0 *= T1 */
                gen_op_mov_reg_T0(OT_WORD, R_EAX); /* EAX = T0 */
                tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);
                tcg_gen_shri_tl(cpu_T[0], cpu_T[0], 16);
                gen_op_mov_reg_T0(OT_WORD, R_EDX); /* 将T0的高16bit放入EDX */
                tcg_gen_mov_tl(cpu_cc_src, cpu_T[0]);
                s->cc_op = CC_OP_MULW;
                break;
            default:
                // ...
            }
            break;
			// ...
        case 6: /* div */
            switch(ot) {
            case OT_BYTE:
                gen_jmp_im(pc_start - s->cs_base);
                gen_helper_divb_AL(cpu_T[0]);
                break;
            case OT_WORD:
                gen_jmp_im(pc_start - s->cs_base);
                gen_helper_divw_AX(cpu_T[0]);
                break;
            default:
            case OT_LONG:
                gen_jmp_im(pc_start - s->cs_base);
                gen_helper_divl_EAX(cpu_T[0]);
                break;
            }
            break;
			// ...
        default:
            goto illegal_op;
        }
        break;

    case 0xfe: /* GRP4 */
    case 0xff: /* GRP5 */
        if ((b & 1) == 0)
            ot = OT_BYTE;
        else
            ot = dflag + OT_WORD;

        modrm = ldub_code(s->pc++);
        mod = (modrm >> 6) & 3; /* 寻址方式 */
        rm = (modrm & 7) | REX_B(s);
        op = (modrm >> 3) & 7; /* 操作码 */
        if (op >= 2 && b == 0xfe) {
            goto illegal_op;
        }
        if (CODE64(s)) {
            if (op == 2 || op == 4) {
                /* operand size for jumps is 64 bit */
                ot = OT_QUAD;
            } else if (op == 3 || op == 5) {
                /* for call calls, the operand is 16 or 32 bit, even
                   in long mode */
                ot = dflag ? OT_LONG : OT_WORD;
            } else if (op == 6) {
                /* default push size is 64 bit */
                ot = dflag ? OT_QUAD : OT_WORD;
            }
        }
        if (mod != 3) { /* 寄存器间接寻址 */
            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);
            if (op >= 2 && op != 3 && op != 5)
                gen_op_ld_T0_A0(ot + s->mem_index);
        } else { /* 寄存器直接寻址 */
            gen_op_mov_TN_reg(ot, 0, rm); /* 首先将第一个操作数加载值T0寄存器 */
        }

        switch(op) {
        case 0: /* inc Ev */
            if (mod != 3) /* 寄存器间接寻址 */
                opreg = OR_TMP0;
            else /* 寄存器直接寻址 */
                opreg = rm;
            gen_inc(s, ot, opreg, 1); /* 自增指令 */
            break;
        case 1: /* dec Ev */
            if (mod != 3) /* 寄存器间接寻址 */
                opreg = OR_TMP0;
            else /* 寄存器直接寻址 */
                opreg = rm;
            gen_inc(s, ot, opreg, -1); /* 自减指令 */
            break;
        case 2: /* call Ev */
            /* 函数调用 */
            if (s->dflag == 0)
                gen_op_andl_T0_ffff();
            next_eip = s->pc - s->cs_base;
            gen_movtl_T1_im(next_eip); /* T1中记录返回地址 */
            gen_push_T1(s); /* 将T1压栈 */
            gen_op_jmp_T0(); /* 跳转到T0 */
            gen_eob(s);
            break;
        case 3: /* lcall Ev */
            gen_op_ld_T1_A0(ot + s->mem_index);
            gen_add_A0_im(s, 1 << (ot - OT_WORD + 1));
            gen_op_ldu_T0_A0(OT_WORD + s->mem_index);
        do_lcall:
            if (s->pe && !s->vm86) {
                if (s->cc_op != CC_OP_DYNAMIC)
                    gen_op_set_cc_op(s->cc_op);
                gen_jmp_im(pc_start - s->cs_base);
                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);
                gen_helper_lcall_protected(cpu_tmp2_i32, cpu_T[1],
                                           tcg_const_i32(dflag), 
                                           tcg_const_i32(s->pc - pc_start));
            } else {
                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);
                gen_helper_lcall_real(cpu_tmp2_i32, cpu_T[1],
                                      tcg_const_i32(dflag), 
                                      tcg_const_i32(s->pc - s->cs_base));
            }
            gen_eob(s);
            break;
        case 4: /* jmp Ev */
            if (s->dflag == 0)
                gen_op_andl_T0_ffff(); /* T0 = T0 & 0xffff */
            gen_op_jmp_T0(); /* 跳转到T0 */
            gen_eob(s);
            break;
        case 5: /* ljmp Ev */
            gen_op_ld_T1_A0(ot + s->mem_index);
            gen_add_A0_im(s, 1 << (ot - OT_WORD + 1));
            gen_op_ldu_T0_A0(OT_WORD + s->mem_index);
        do_ljmp:
            if (s->pe && !s->vm86) {
                if (s->cc_op != CC_OP_DYNAMIC)
                    gen_op_set_cc_op(s->cc_op);
                gen_jmp_im(pc_start - s->cs_base);
                tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);
                gen_helper_ljmp_protected(cpu_tmp2_i32, cpu_T[1],
                                          tcg_const_i32(s->pc - pc_start));
            } else {
                gen_op_movl_seg_T0_vm(R_CS);
                gen_op_movl_T0_T1();
                gen_op_jmp_T0();
            }
            gen_eob(s);
            break;
        case 6: /* push Ev */
            gen_push_T0(s);
            break;
        default:
            goto illegal_op;
        }
        break;

    case 0x84: /* test Ev, Gv */
    case 0x85:
        if ((b & 1) == 0)
            ot = OT_BYTE;
        else
            ot = dflag + OT_WORD;

        modrm = ldub_code(s->pc++);
        mod = (modrm >> 6) & 3;
        rm = (modrm & 7) | REX_B(s);
        reg = ((modrm >> 3) & 7) | rex_r;

        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 0);
        gen_op_mov_TN_reg(ot, 1, reg);
        gen_op_testl_T0_T1_cc();
        s->cc_op = CC_OP_LOGICB + ot;
        break;

    case 0xa8: /* test eAX, Iv */
    case 0xa9:
        if ((b & 1) == 0)
            ot = OT_BYTE;
        else
            ot = dflag + OT_WORD;
        val = insn_get(s, ot);

        gen_op_mov_TN_reg(ot, 0, OR_EAX);
        gen_op_movl_T1_im(val);
        gen_op_testl_T0_T1_cc();
        s->cc_op = CC_OP_LOGICB + ot;
        break;
	// ...
    case 0x1c0:
    case 0x1c1: /* xadd Ev, Gv */
        if ((b & 1) == 0)
            ot = OT_BYTE;
        else
            ot = dflag + OT_WORD;
        modrm = ldub_code(s->pc++);
        reg = ((modrm >> 3) & 7) | rex_r;
        mod = (modrm >> 6) & 3;
        if (mod == 3) { /* 寄存器直接寻址 */
            rm = (modrm & 7) | REX_B(s);
            gen_op_mov_TN_reg(ot, 0, reg);
            gen_op_mov_TN_reg(ot, 1, rm);
            gen_op_addl_T0_T1();
            gen_op_mov_reg_T1(ot, reg);
            gen_op_mov_reg_T0(ot, rm);
        } else { /* 寄存器间接寻址 */
            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);
            gen_op_mov_TN_reg(ot, 0, reg);
            gen_op_ld_T1_A0(ot + s->mem_index);
            gen_op_addl_T0_T1();
            gen_op_st_T0_A0(ot + s->mem_index);
            gen_op_mov_reg_T1(ot, reg);
        }
        gen_op_update2_cc();
        s->cc_op = CC_OP_ADDB + ot;
        break;
	// ...
        /**************************/
        /* push/pop */
    case 0x50 ... 0x57: /* push */
        gen_op_mov_TN_reg(OT_LONG, 0, (b & 7) | REX_B(s)); /* T0 = reg */
        gen_push_T0(s); /* 然后将T0压栈 */
        break;
    case 0x58 ... 0x5f: /* pop */
        if (CODE64(s)) {
            ot = dflag ? OT_QUAD : OT_WORD;
        } else {
            ot = dflag + OT_WORD;
        }
        gen_pop_T0(s); /* 将栈顶元素放入T0寄存器 */
        /* NOTE: order is important for pop %sp */
        gen_pop_update(s);
        gen_op_mov_reg_T0(ot, (b & 7) | REX_B(s)); /* reg = T0 */
        break;
    case 0x60: /* pusha */
        if (CODE64(s))
            goto illegal_op;
        gen_pusha(s);
        break;
    case 0x61: /* popa */
        if (CODE64(s))
            goto illegal_op;
        gen_popa(s);
        break;
    case 0x68: /* push Iv */
    case 0x6a:
        if (CODE64(s)) {
            ot = dflag ? OT_QUAD : OT_WORD;
        } else {
            ot = dflag + OT_WORD;
        }
        if (b == 0x68)
            val = insn_get(s, ot); /* 读取出立即数的值 */
        else
            val = (int8_t)insn_get(s, OT_BYTE);
        gen_op_movl_T0_im(val); /* T0 = im */
        gen_push_T0(s); /* 将T0压栈 */
        break;
    case 0x8f: /* pop Ev */
        if (CODE64(s)) {
            ot = dflag ? OT_QUAD : OT_WORD;
        } else {
            ot = dflag + OT_WORD;
        }
        modrm = ldub_code(s->pc++);
        mod = (modrm >> 6) & 3;
        gen_pop_T0(s);
        if (mod == 3) {
            /* NOTE: order is important for pop %sp */
            gen_pop_update(s);
            rm = (modrm & 7) | REX_B(s);
            gen_op_mov_reg_T0(ot, rm);
        } else {
            /* NOTE: order is important too for MMU exceptions */
            s->popl_esp_hack = 1 << ot;
            gen_ldst_modrm(s, modrm, ot, OR_TMP0, 1);
            s->popl_esp_hack = 0;
            gen_pop_update(s);
        }
        break;
    case 0xc8: /* enter */
        {
            int level;
            val = lduw_code(s->pc);
            s->pc += 2;
            level = ldub_code(s->pc++);
            gen_enter(s, val, level);
        }
        break;
    case 0xc9: /* leave */
        /* XXX: exception not precise (ESP is updated before potential exception) */
        if (CODE64(s)) {
            gen_op_mov_TN_reg(OT_QUAD, 0, R_EBP);
            gen_op_mov_reg_T0(OT_QUAD, R_ESP);
        } else if (s->ss32) {
            gen_op_mov_TN_reg(OT_LONG, 0, R_EBP);
            gen_op_mov_reg_T0(OT_LONG, R_ESP);
        } else {
            gen_op_mov_TN_reg(OT_WORD, 0, R_EBP);
            gen_op_mov_reg_T0(OT_WORD, R_ESP);
        }
        gen_pop_T0(s);
        if (CODE64(s)) {
            ot = dflag ? OT_QUAD : OT_WORD;
        } else {
            ot = dflag + OT_WORD;
        }
        gen_op_mov_reg_T0(ot, R_EBP);
        gen_pop_update(s);
        break;
    case 0x06: /* push es */
    case 0x0e: /* push cs */
    case 0x16: /* push ss */
    case 0x1e: /* push ds */
        if (CODE64(s))
            goto illegal_op;
        gen_op_movl_T0_seg(b >> 3);
        gen_push_T0(s);
        break;
    case 0x1a0: /* push fs */
    case 0x1a8: /* push gs */
        gen_op_movl_T0_seg((b >> 3) & 7);
        gen_push_T0(s);
        break;
    case 0x07: /* pop es */
    case 0x17: /* pop ss */
    case 0x1f: /* pop ds */
        if (CODE64(s))
            goto illegal_op;
        reg = b >> 3;
        gen_pop_T0(s);
        gen_movl_seg_T0(s, reg, pc_start - s->cs_base);
        gen_pop_update(s);
        if (reg == R_SS) {
            /* if reg == SS, inhibit interrupts/trace. */
            /* If several instructions disable interrupts, only the
               _first_ does it */
            if (!(s->tb->flags & HF_INHIBIT_IRQ_MASK))
                gen_helper_set_inhibit_irq();
            s->tf = 0;
        }
        if (s->is_jmp) {
            gen_jmp_im(s->pc - s->cs_base);
            gen_eob(s);
        }
        break;
    case 0x1a1: /* pop fs */
    case 0x1a9: /* pop gs */
        gen_pop_T0(s);
        gen_movl_seg_T0(s, (b >> 3) & 7, pc_start - s->cs_base);
        gen_pop_update(s);
        if (s->is_jmp) {
            gen_jmp_im(s->pc - s->cs_base);
            gen_eob(s);
        }
        break;

        /**************************/
        /* mov */
    case 0x88:
    case 0x89: /* mov Gv, Ev */
        if ((b & 1) == 0)
            ot = OT_BYTE;
        else
            ot = dflag + OT_WORD;
        modrm = ldub_code(s->pc++);
        reg = ((modrm >> 3) & 7) | rex_r;

        /* generate a generic store */
        /* 产生一条通用的store指令 */
        gen_ldst_modrm(s, modrm, ot, reg, 1);
        break;
    case 0xc6:
    case 0xc7: /* mov Ev, Iv */
        if ((b & 1) == 0)
            ot = OT_BYTE;
        else
            ot = dflag + OT_WORD;
        modrm = ldub_code(s->pc++);
        mod = (modrm >> 6) & 3;
        if (mod != 3) {
            s->rip_offset = insn_const_size(ot);
            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);
        }
        val = insn_get(s, ot);
        gen_op_movl_T0_im(val);
        if (mod != 3)
            gen_op_st_T0_A0(ot + s->mem_index);
        else
            gen_op_mov_reg_T0(ot, (modrm & 7) | REX_B(s));
        break;
    case 0x8a:
    case 0x8b: /* mov Ev, Gv */
        if ((b & 1) == 0)
            ot = OT_BYTE;
        else
            ot = OT_WORD + dflag;
        modrm = ldub_code(s->pc++);
        reg = ((modrm >> 3) & 7) | rex_r;

        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 0);
        gen_op_mov_reg_T0(ot, reg);
        break;
    case 0x8e: /* mov seg, Gv */
        modrm = ldub_code(s->pc++);
        reg = (modrm >> 3) & 7;
        if (reg >= 6 || reg == R_CS)
            goto illegal_op;
        gen_ldst_modrm(s, modrm, OT_WORD, OR_TMP0, 0);
        gen_movl_seg_T0(s, reg, pc_start - s->cs_base);
        if (reg == R_SS) {
            /* if reg == SS, inhibit interrupts/trace */
            /* If several instructions disable interrupts, only the
               _first_ does it */
            if (!(s->tb->flags & HF_INHIBIT_IRQ_MASK))
                gen_helper_set_inhibit_irq();
            s->tf = 0;
        }
        if (s->is_jmp) {
            gen_jmp_im(s->pc - s->cs_base);
            gen_eob(s);
        }
        break;
    case 0x8c: /* mov Gv, seg */
        modrm = ldub_code(s->pc++);
        reg = (modrm >> 3) & 7;
        mod = (modrm >> 6) & 3;
        if (reg >= 6)
            goto illegal_op;
        gen_op_movl_T0_seg(reg);
        if (mod == 3)
            ot = OT_WORD + dflag;
        else
            ot = OT_WORD;
        gen_ldst_modrm(s, modrm, ot, OR_TMP0, 1);
        break;

    case 0x1b6: /* movzbS Gv, Eb */
    case 0x1b7: /* movzwS Gv, Eb */
    case 0x1be: /* movsbS Gv, Eb */
    case 0x1bf: /* movswS Gv, Eb */
        {
            int d_ot;
            /* d_ot is the size of destination */
            d_ot = dflag + OT_WORD;
            /* ot is the size of source */
            ot = (b & 1) + OT_BYTE;
            modrm = ldub_code(s->pc++);
            reg = ((modrm >> 3) & 7) | rex_r;
            mod = (modrm >> 6) & 3;
            rm = (modrm & 7) | REX_B(s);

            if (mod == 3) { /* 寄存器直接寻址 */
                gen_op_mov_TN_reg(ot, 0, rm);
                switch(ot | (b & 8)) {
                case OT_BYTE:
                    tcg_gen_ext8u_tl(cpu_T[0], cpu_T[0]);
                    break;
                case OT_BYTE | 8:
                    tcg_gen_ext8s_tl(cpu_T[0], cpu_T[0]);
                    break;
                case OT_WORD:
                    tcg_gen_ext16u_tl(cpu_T[0], cpu_T[0]);
                    break;
                default:
                case OT_WORD | 8:
                    tcg_gen_ext16s_tl(cpu_T[0], cpu_T[0]);
                    break;
                }
                gen_op_mov_reg_T0(d_ot, reg);
            } else { /* 寄存器间接寻址 */
                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);
                if (b & 8) {
                    gen_op_lds_T0_A0(ot + s->mem_index);
                } else {
                    gen_op_ldu_T0_A0(ot + s->mem_index);
                }
                gen_op_mov_reg_T0(d_ot, reg);
            }
        }
        break;

    case 0x8d: /* lea */
        ot = dflag + OT_WORD;
        modrm = ldub_code(s->pc++);
        mod = (modrm >> 6) & 3;
        if (mod == 3)
            goto illegal_op;
        reg = ((modrm >> 3) & 7) | rex_r;
        /* we must ensure that no segment is added */
        s->override = -1;
        val = s->addseg;
        s->addseg = 0;
        gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);
        s->addseg = val;
        gen_op_mov_reg_A0(ot - OT_WORD, reg);
        break;

    case 0xa0: /* mov EAX, Ov */
    case 0xa1:
    case 0xa2: /* mov Ov, EAX */
    case 0xa3:
        {
            target_ulong offset_addr;

            if ((b & 1) == 0)
                ot = OT_BYTE;
            else
                ot = dflag + OT_WORD;
            {
                if (s->aflag) {
                    offset_addr = insn_get(s, OT_LONG);
                } else {
                    offset_addr = insn_get(s, OT_WORD);
                }
                gen_op_movl_A0_im(offset_addr);
            }
            gen_add_A0_ds_seg(s);
            if ((b & 2) == 0) {
                gen_op_ld_T0_A0(ot + s->mem_index);
                gen_op_mov_reg_T0(ot, R_EAX);
            } else {
                gen_op_mov_TN_reg(ot, 0, R_EAX);
                gen_op_st_T0_A0(ot + s->mem_index);
            }
        }
        break;
 	// ...

        /************************/
        /* shifts */
	// ...
        /************************/
        /* floats */
	// ...
        /************************/
        /* string ops */
	// ...
        /************************/
        /* port I/O */
    case 0xe4:
    case 0xe5:
        if ((b & 1) == 0)
            ot = OT_BYTE;
        else
            ot = dflag ? OT_LONG : OT_WORD;
        val = ldub_code(s->pc++); /* 加载立即数 */
        gen_op_movl_T0_im(val); /* 立即数放入T0 */
        gen_check_io(s, ot, pc_start - s->cs_base,
                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));
        if (use_icount)
            gen_io_start();
        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);
        gen_helper_in_func(ot, cpu_T[1], cpu_tmp2_i32);
        gen_op_mov_reg_T1(ot, R_EAX);
        if (use_icount) {
            gen_io_end();
            gen_jmp(s, s->pc - s->cs_base);
        }
        break;
    case 0xe6:
    case 0xe7:
        if ((b & 1) == 0)
            ot = OT_BYTE;
        else
            ot = dflag ? OT_LONG : OT_WORD;
        val = ldub_code(s->pc++);
        gen_op_movl_T0_im(val);
        gen_check_io(s, ot, pc_start - s->cs_base,
                     svm_is_rep(prefixes));
        gen_op_mov_TN_reg(ot, 1, R_EAX);

        if (use_icount)
            gen_io_start();
        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);
        tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);
        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[1]);
        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);
        if (use_icount) {
            gen_io_end();
            gen_jmp(s, s->pc - s->cs_base);
        }
        break;
    case 0xec:
    case 0xed:
        if ((b & 1) == 0)
            ot = OT_BYTE;
        else
            ot = dflag ? OT_LONG : OT_WORD;
        gen_op_mov_TN_reg(OT_WORD, 0, R_EDX);
        gen_op_andl_T0_ffff();
        gen_check_io(s, ot, pc_start - s->cs_base,
                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));
        if (use_icount)
            gen_io_start();
        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);
        gen_helper_in_func(ot, cpu_T[1], cpu_tmp2_i32);
        gen_op_mov_reg_T1(ot, R_EAX);
        if (use_icount) {
            gen_io_end();
            gen_jmp(s, s->pc - s->cs_base);
        }
        break;
    case 0xee:
    case 0xef:
        if ((b & 1) == 0)
            ot = OT_BYTE;
        else
            ot = dflag ? OT_LONG : OT_WORD;
        gen_op_mov_TN_reg(OT_WORD, 0, R_EDX);
        gen_op_andl_T0_ffff();
        gen_check_io(s, ot, pc_start - s->cs_base,
                     svm_is_rep(prefixes));
        gen_op_mov_TN_reg(ot, 1, R_EAX);

        if (use_icount)
            gen_io_start();
        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]);
        tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);
        tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[1]);
        gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);
        if (use_icount) {
            gen_io_end();
            gen_jmp(s, s->pc - s->cs_base);
        }
        break;

        /************************/
        /* control */
    case 0xc2: /* ret im */
        val = ldsw_code(s->pc);
        s->pc += 2;
        gen_pop_T0(s);
        if (CODE64(s) && s->dflag)
            s->dflag = 2;
        gen_stack_update(s, val + (2 << s->dflag));
        if (s->dflag == 0)
            gen_op_andl_T0_ffff();
        gen_op_jmp_T0();
        gen_eob(s);
        break;
    case 0xc3: /* ret */
        gen_pop_T0(s);
        gen_pop_update(s);
        if (s->dflag == 0)
            gen_op_andl_T0_ffff();
        gen_op_jmp_T0();
        gen_eob(s);
        break;
    case 0xca: /* lret im */
        val = ldsw_code(s->pc);
        s->pc += 2;
    do_lret:
        if (s->pe && !s->vm86) {
            if (s->cc_op != CC_OP_DYNAMIC)
                gen_op_set_cc_op(s->cc_op);
            gen_jmp_im(pc_start - s->cs_base);
            gen_helper_lret_protected(tcg_const_i32(s->dflag),
                                      tcg_const_i32(val));
        } else {
            gen_stack_A0(s);
            /* pop offset */
            gen_op_ld_T0_A0(1 + s->dflag + s->mem_index);
            if (s->dflag == 0)
                gen_op_andl_T0_ffff();
            /* NOTE: keeping EIP updated is not a problem in case of
               exception */
            gen_op_jmp_T0();
            /* pop selector */
            gen_op_addl_A0_im(2 << s->dflag);
            gen_op_ld_T0_A0(1 + s->dflag + s->mem_index);
            gen_op_movl_seg_T0_vm(R_CS);
            /* add stack offset */
            gen_stack_update(s, val + (4 << s->dflag));
        }
        gen_eob(s);
        break;
    case 0xcb: /* lret */
        val = 0;
        goto do_lret;
    case 0xcf: /* iret */
        gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET);
        if (!s->pe) {
            /* real mode */
            gen_helper_iret_real(tcg_const_i32(s->dflag));
            s->cc_op = CC_OP_EFLAGS;
        } else if (s->vm86) {
            if (s->iopl != 3) {
                gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
            } else {
                gen_helper_iret_real(tcg_const_i32(s->dflag));
                s->cc_op = CC_OP_EFLAGS;
            }
        } else {
            if (s->cc_op != CC_OP_DYNAMIC)
                gen_op_set_cc_op(s->cc_op);
            gen_jmp_im(pc_start - s->cs_base);
            gen_helper_iret_protected(tcg_const_i32(s->dflag), 
                                      tcg_const_i32(s->pc - s->cs_base));
            s->cc_op = CC_OP_EFLAGS;
        }
        gen_eob(s);
        break;
    case 0xe8: /* call im */
        {
            if (dflag)
                tval = (int32_t)insn_get(s, OT_LONG);
            else
                tval = (int16_t)insn_get(s, OT_WORD);
            next_eip = s->pc - s->cs_base;
            tval += next_eip;
            if (s->dflag == 0)
                tval &= 0xffff;
            gen_movtl_T0_im(next_eip);
            gen_push_T0(s);
            gen_jmp(s, tval);
        }
        break;
    case 0x9a: /* lcall im */
        {
            unsigned int selector, offset;

            if (CODE64(s))
                goto illegal_op;
            ot = dflag ? OT_LONG : OT_WORD;
            offset = insn_get(s, ot);
            selector = insn_get(s, OT_WORD);

            gen_op_movl_T0_im(selector);
            gen_op_movl_T1_imu(offset);
        }
        goto do_lcall;
    case 0xe9: /* jmp im */
        if (dflag)
            tval = (int32_t)insn_get(s, OT_LONG);
        else
            tval = (int16_t)insn_get(s, OT_WORD);
        tval += s->pc - s->cs_base;
        if (s->dflag == 0)
            tval &= 0xffff;
        else if(!CODE64(s))
            tval &= 0xffffffff;
        gen_jmp(s, tval);
        break;
    case 0xea: /* ljmp im */
        {
            unsigned int selector, offset;

            if (CODE64(s))
                goto illegal_op;
            ot = dflag ? OT_LONG : OT_WORD;
            offset = insn_get(s, ot);
            selector = insn_get(s, OT_WORD);

            gen_op_movl_T0_im(selector);
            gen_op_movl_T1_imu(offset);
        }
        goto do_ljmp;
    case 0xeb: /* jmp Jb */
        tval = (int8_t)insn_get(s, OT_BYTE);
        tval += s->pc - s->cs_base;
        if (s->dflag == 0)
            tval &= 0xffff;
        gen_jmp(s, tval);
        break;
    case 0x70 ... 0x7f: /* jcc Jb */
        tval = (int8_t)insn_get(s, OT_BYTE);
        goto do_jcc;
    case 0x180 ... 0x18f: /* jcc Jv */
        if (dflag) {
            tval = (int32_t)insn_get(s, OT_LONG);
        } else {
            tval = (int16_t)insn_get(s, OT_WORD);
        }
    do_jcc:
        next_eip = s->pc - s->cs_base;
        tval += next_eip;
        if (s->dflag == 0)
            tval &= 0xffff;
        gen_jcc(s, b, tval, next_eip);
        break;

    case 0x190 ... 0x19f: /* setcc Gv */
        modrm = ldub_code(s->pc++);
        gen_setcc(s, b);
        gen_ldst_modrm(s, modrm, OT_BYTE, OR_TMP0, 1);
        break;
    case 0x140 ... 0x14f: /* cmov Gv, Ev */
        {
            int l1;
            TCGv t0;

            ot = dflag + OT_WORD;
            modrm = ldub_code(s->pc++);
            reg = ((modrm >> 3) & 7) | rex_r;
            mod = (modrm >> 6) & 3;
            t0 = tcg_temp_local_new();
            if (mod != 3) {
                gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);
                gen_op_ld_v(ot + s->mem_index, t0, cpu_A0);
            } else {
                rm = (modrm & 7) | REX_B(s);
                gen_op_mov_v_reg(ot, t0, rm);
            }
            {
                l1 = gen_new_label();
                gen_jcc1(s, s->cc_op, b ^ 1, l1);
                gen_op_mov_reg_v(ot, reg, t0);
                gen_set_label(l1);
            }
            tcg_temp_free(t0);
        }
        break;
        /************************/
        /* flags */
    case 0x9c: /* pushf */
        gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF);
        if (s->vm86 && s->iopl != 3) {
            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
        } else {
            if (s->cc_op != CC_OP_DYNAMIC)
                gen_op_set_cc_op(s->cc_op);
            gen_helper_read_eflags(cpu_T[0]);
            gen_push_T0(s);
        }
        break;
    case 0x9d: /* popf */
        gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF);
        if (s->vm86 && s->iopl != 3) {
            gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base);
        } else {
            gen_pop_T0(s);
            if (s->cpl == 0) {
                if (s->dflag) {
                    gen_helper_write_eflags(cpu_T[0],
                       tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK)));
                } else {
                    gen_helper_write_eflags(cpu_T[0],
                         tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK) & 0xffff));
                }
            } else {
                if (s->cpl <= s->iopl) {
                    if (s->dflag) {
                        gen_helper_write_eflags(cpu_T[0],
                           tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK)));
                    } else {
                        gen_helper_write_eflags(cpu_T[0],
                            tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK) & 0xffff));
                    }
                } else {
                    if (s->dflag) {
                        gen_helper_write_eflags(cpu_T[0],
                             tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK)));
                    } else {
                        gen_helper_write_eflags(cpu_T[0],
                             tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK) & 0xffff));
                    }
                }
            }
            gen_pop_update(s);
            s->cc_op = CC_OP_EFLAGS;
            /* abort translation because TF flag may change */
            gen_jmp_im(s->pc - s->cs_base);
            gen_eob(s);
        }
        break;
    case 0x9e: /* sahf */
        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))
            goto illegal_op;
        gen_op_mov_TN_reg(OT_BYTE, 0, R_AH);
        if (s->cc_op != CC_OP_DYNAMIC)
            gen_op_set_cc_op(s->cc_op);
        gen_compute_eflags(cpu_cc_src);
        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O);
        tcg_gen_andi_tl(cpu_T[0], cpu_T[0], CC_S | CC_Z | CC_A | CC_P | CC_C);
        tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T[0]);
        s->cc_op = CC_OP_EFLAGS;
        break;
    case 0x9f: /* lahf */
        if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM))
            goto illegal_op;
        if (s->cc_op != CC_OP_DYNAMIC)
            gen_op_set_cc_op(s->cc_op);
        gen_compute_eflags(cpu_T[0]);
        /* Note: gen_compute_eflags() only gives the condition codes */
        tcg_gen_ori_tl(cpu_T[0], cpu_T[0], 0x02);
        gen_op_mov_reg_T0(OT_BYTE, R_AH);
        break;
    case 0xf5: /* cmc */
        if (s->cc_op != CC_OP_DYNAMIC)
            gen_op_set_cc_op(s->cc_op);
        gen_compute_eflags(cpu_cc_src);
        tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C);
        s->cc_op = CC_OP_EFLAGS;
        break;
    case 0xf8: /* clc */
        if (s->cc_op != CC_OP_DYNAMIC)
            gen_op_set_cc_op(s->cc_op);
        gen_compute_eflags(cpu_cc_src);
        tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C);
        s->cc_op = CC_OP_EFLAGS;
        break;
    case 0xf9: /* stc */
        if (s->cc_op != CC_OP_DYNAMIC)
            gen_op_set_cc_op(s->cc_op);
        gen_compute_eflags(cpu_cc_src);
        tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C);
        s->cc_op = CC_OP_EFLAGS;
        break;
    case 0xfc: /* cld */
        tcg_gen_movi_i32(cpu_tmp2_i32, 1);
        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUState, df));
        break;
    case 0xfd: /* std */
        tcg_gen_movi_i32(cpu_tmp2_i32, -1);
        tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUState, df));
        break;

        /************************/
        /* bit operations */
	// ...
        /************************/
        /* bcd */
	// ...
        /************************/
        /* misc */
	// ...
    default:
        goto illegal_op;
    }
    /* lock generation */
    if (s->prefix & PREFIX_LOCK)
        gen_helper_unlock();
    return s->pc;
 illegal_op:
    if (s->prefix & PREFIX_LOCK)
        gen_helper_unlock();
    /* XXX: ensure that no lock was generated */
    gen_exception(s, EXCP06_ILLOP, pc_start - s->cs_base);
    return s->pc;
}
```

#### call Ev

T0中保存着要跳转的地址.

```c
// ...
    case 0xff: /* GRP5 */
        if ((b & 1) == 0)
            ot = OT_BYTE;
        else
            ot = dflag + OT_WORD;

        modrm = ldub_code(s->pc++);
        mod = (modrm >> 6) & 3; /* 寻址方式 */
        rm = (modrm & 7) | REX_B(s);
        op = (modrm >> 3) & 7; /* 操作码 */
        if (op >= 2 && b == 0xfe) {
            goto illegal_op;
        }
 		// ...
        if (mod != 3) {
            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr); /* 将第一个操作数地址加载至A0 */
            if (op >= 2 && op != 3 && op != 5)
                gen_op_ld_T0_A0(ot + s->mem_index); /* 将操作数从A0指向的地址加载到T0寄存器 */
        } else { /* 直接寻址 */
            gen_op_mov_TN_reg(ot, 0, rm); /* 首先将第一个操作数加载值T0寄存器 */
        }
		switch(op) {
        case 2: /* call Ev */
            /* 函数调用 */
            if (s->dflag == 0)
                gen_op_andl_T0_ffff();
            next_eip = s->pc - s->cs_base; /* 获取返回地址 */
            gen_movtl_T1_im(next_eip); /* T1中记录返回地址 */
            gen_push_T1(s); /* 将T1压栈 */
            gen_op_jmp_T0(); /* 跳转到T0 */
            gen_eob(s);
            break;
//...
```

`gen_push_T1` 用于将T1中的参数压栈.

```c
/* generate a push. It depends on ss32, addseg and dflag */
/* 为push生成指令 */
static void gen_push_T1(DisasContext *s)
{
    {
        gen_op_movl_A0_reg(R_ESP); /* 先将ESP -> A0 */
        if (!s->dflag)
            gen_op_addl_A0_im(-2); /* A0 -= 2 */
        else
            gen_op_addl_A0_im(-4); /* A0 -= 4 */
        if (s->ss32) {
            if (s->addseg) {
                gen_op_addl_A0_seg(R_SS);
            }
        } else {
            gen_op_andl_A0_ffff(); /* A0 = A0 & 0xffff */
            gen_op_addl_A0_seg(R_SS);
        }
        gen_op_st_T1_A0(s->dflag + 1 + s->mem_index); /* T1存储到A0指向的地址 */

        if (s->ss32 && !s->addseg)
            gen_op_mov_reg_A0(1, R_ESP); /* A0 -> ESP */
        else
            gen_stack_update(s, (-2) << s->dflag);
    }
}
```

`gen_op_jmp_T0` 用于生成跳转指令,这里生成的指令是非常有意思的,它是直接更改所模拟的cpu的eip寄存器的值,从而实现跳转.

```c
/* st_i32 t0, t1, 0ffset ==> write(t0, t1 + offset) 写32bit到t1+offset指示的内存去 */
static inline void tcg_gen_st_i32(TCGv_i32 arg1, TCGv_ptr arg2, tcg_target_long offset)
{
    tcg_gen_ldst_op_i32(INDEX_op_st_i32, arg1, arg2, offset);
}

static inline void gen_op_jmp_T0(void)
{
    tcg_gen_st_tl(cpu_T[0], cpu_env, offsetof(CPUState, eip));
}
```

`gen_eob` 用于退出block.

```c
/* generate a generic end of block. Trace exception is also generated
   if needed */
static void gen_eob(DisasContext *s)
{
    if (s->cc_op != CC_OP_DYNAMIC)
        gen_op_set_cc_op(s->cc_op);
    if (s->tb->flags & HF_INHIBIT_IRQ_MASK) {
        gen_helper_reset_inhibit_irq();
    }
    if (s->singlestep_enabled) {
        gen_helper_debug();
    } else if (s->tf) {
		gen_helper_single_step();
    } else {
        tcg_gen_exit_tb(0);
    }
    s->is_jmp = 3; /* 这里更改is_jmp的值 */
}
```

#### port I/O

port指令用于访问端口的信息.

```c
// ...
    case 0xe5:
        if ((b & 1) == 0)
            ot = OT_BYTE;
        else
            ot = dflag ? OT_LONG : OT_WORD; /* 操作数宽度 */
        val = ldub_code(s->pc++); /* 加载立即数 */
        gen_op_movl_T0_im(val); /* 立即数放入T0 */
        gen_check_io(s, ot, pc_start - s->cs_base,
                     SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes));
        if (use_icount)
            gen_io_start();
        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T[0]); /* 将T0中的值放入cpu_tmp2_i32之中 */
        gen_helper_in_func(ot, cpu_T[1], cpu_tmp2_i32); /* 读取的值放入T1 */
        gen_op_mov_reg_T1(ot, R_EAX); /* T1的值移动到EAX */
        if (use_icount) {
            gen_io_end();
            gen_jmp(s, s->pc - s->cs_base);
        }
        break;
// ...
```

`gen_helper_in_func` 用于生成指令,读取端口的数据.

```c
static void gen_helper_in_func(int ot, TCGv v, TCGv_i32 n)
{
    switch (ot) {
    case 0: gen_helper_inb(v, n); break;
    case 1: gen_helper_inw(v, n); break;
    case 2: gen_helper_inl(v, n); break;
    }
}
```

我们以`gen_helper_inb` 为例,看一看它的实现,值得注意的是,这里的端口是我们虚拟出来的.

```c
// def-helper.h

#define dh_retvar_decl_void
#define dh_retvar_decl_i32 TCGv_i32 retval,
#define dh_retvar_decl_i64 TCGv_i64 retval,
#define dh_retvar_decl_ptr TCGv_iptr retval,
#define dh_retvar_decl(t) glue(dh_retvar_decl_, dh_alias(t))

#define dh_ctype_i32 uint32_t
#define dh_ctype(t) dh_ctype_##t
#define HELPER(name) glue(helper_, name)

#define DEF_HELPER_FLAGS_1(name, flags, ret, t1) \
dh_ctype(ret) HELPER(name) (dh_ctype(t1));

#define DEF_HELPER_FLAGS_1(name, flags, ret, t1) \
static inline void glue(gen_helper_, name)(dh_retvar_decl(ret) dh_arg_decl(t1, 1)) \
{ \
  TCGArg args[1]; \
  int sizemask; \
  sizemask = dh_is_64bit(ret); \
  dh_arg(t1, 1); \
  tcg_gen_helperN(HELPER(name), flags, sizemask, dh_retvar(ret), 1, args); \
}
```

`DEF_HELPER_1(inb, tl, i32)` 大致可以翻译为:

```c
// helper.h
static inline void gen_helper_inb(TCGv ret, TCGv_i32 t1)
{
    TCGArg args[1];
    int sizemask;
    sizemask = dh_is_64bit(ret);
    dh_arg(t1, 1);
    tcg_gen_helperN(helper_inb, flags, sizemask, , 1, args);
}
```

`tcg_gen_helperN` 的实现其实是相当有意思的,因为它通过构造call指令,直接调用了qemu中自定义的helper函数.

```c
// tcg-op.h

/* Note: we convert the 64 bit args to 32 bit and do some alignment
   and endian swap. Maybe it would be better to do the alignment
   and endian swap in tcg_reg_alloc_call(). */
void tcg_gen_callN(TCGContext *s, TCGv_ptr func, unsigned int flags,
                   int sizemask, TCGArg ret, int nargs, TCGArg *args)
{
    int call_type;
    int i;
    int real_args;
    int nb_rets;
    TCGArg *nparam;
    *gen_opc_ptr++ = INDEX_op_call; /* 生成call指令 */
    nparam = gen_opparam_ptr++;
    call_type = (flags & TCG_CALL_TYPE_MASK);
    if (ret != TCG_CALL_DUMMY_ARG) {
#if TCG_TARGET_REG_BITS < 64
        if (sizemask & 1) {
            *gen_opparam_ptr++ = ret;
            *gen_opparam_ptr++ = ret + 1;
            nb_rets = 2;
        } else
#endif
        {
            *gen_opparam_ptr++ = ret;
            nb_rets = 1;
        }
    } else {
        nb_rets = 0;
    }
    real_args = 0;
    for (i = 0; i < nargs; i++) { /* 遍历参数 */
#if TCG_TARGET_REG_BITS < 64
        if (sizemask & (2 << i)) {
#ifdef TCG_TARGET_I386
            /* REGPARM case: if the third parameter is 64 bit, it is
               allocated on the stack */
            if (i == 2 && call_type == TCG_CALL_TYPE_REGPARM) {
                call_type = TCG_CALL_TYPE_REGPARM_2;
                flags = (flags & ~TCG_CALL_TYPE_MASK) | call_type;
            }
#endif
#ifdef TCG_TARGET_CALL_ALIGN_ARGS
            /* some targets want aligned 64 bit args */
            if (real_args & 1) {
                *gen_opparam_ptr++ = TCG_CALL_DUMMY_ARG;
                real_args++;
            }
#endif
            *gen_opparam_ptr++ = args[i];
            *gen_opparam_ptr++ = args[i] + 1;
            real_args += 2;
        } else
#endif
        {
            *gen_opparam_ptr++ = args[i];
            real_args++;
        }
    }
    *gen_opparam_ptr++ = GET_TCGV_PTR(func); /* 获得函数地址 */
    *gen_opparam_ptr++ = flags;
    *nparam = (nb_rets << 16) | (real_args + 1);
    /* total parameters, needed to go backward in the instruction stream */
    *gen_opparam_ptr++ = 1 + nb_rets + real_args + 3;
}

/* helper calls */
static inline void tcg_gen_helperN(void *func, int flags, int sizemask,
                                   TCGArg ret, int nargs, TCGArg *args)
{
    TCGv_ptr fn;
    fn = tcg_const_ptr((tcg_target_long)func); /* 函数指针 */
    tcg_gen_callN(&tcg_ctx, fn, flags, sizemask, ret, nargs, args);
    tcg_temp_free_ptr(fn);
}

```

`helper_inb`这个函数用于通过cpu来访问port指向的地址.

```c
// op_helper.c
target_ulong helper_inb(uint32_t port)
{
    return cpu_inb(env, port);
}
```

#### xadd Ev, Gv

xadd是加法指令.

```c
//...
    case 0x1c1: /* xadd Ev, Gv */
        if ((b & 1) == 0)
            ot = OT_BYTE;
        else
            ot = dflag + OT_WORD;
        modrm = ldub_code(s->pc++);
        reg = ((modrm >> 3) & 7) | rex_r;
        mod = (modrm >> 6) & 3;
        if (mod == 3) { /* 直接寻址 */
            rm = (modrm & 7) | REX_B(s);
            gen_op_mov_TN_reg(ot, 0, reg); /* 操作数1加载至T0 */
            gen_op_mov_TN_reg(ot, 1, rm); /* 操作数2加载至T1 */
            gen_op_addl_T0_T1(); /* T0 += T1 */
            gen_op_mov_reg_T1(ot, reg); /* T1的值移动到寄存器reg */
            gen_op_mov_reg_T0(ot, rm); /* T0的值移动到寄存器rm */
        } else {
            gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);
            gen_op_mov_TN_reg(ot, 0, reg);
            gen_op_ld_T1_A0(ot + s->mem_index);
            gen_op_addl_T0_T1();
            gen_op_st_T0_A0(ot + s->mem_index);
            gen_op_mov_reg_T1(ot, reg);
        }
        gen_op_update2_cc();
        s->cc_op = CC_OP_ADDB + ot;
        break;
//...
```

#### OP Ev, Gv

这里的OP可以指代一大类的指令.

```c
// ...
			case 0: /* OP Ev, Gv */
                modrm = ldub_code(s->pc++);
                reg = ((modrm >> 3) & 7) | rex_r; /* 读取reg字段 */
                mod = (modrm >> 6) & 3; /* 读取mod字段 */
                rm = (modrm & 7) | REX_B(s); /* 读取rm字段 */
                if (mod != 3) { /* mod为3表示直接寻址 */
                    gen_lea_modrm(s, modrm, &reg_addr, &offset_addr);
                    opreg = OR_TMP0;
                } else if (op == OP_XORL && rm == reg) {
                xor_zero:
                    /* xor reg, reg optimisation */
                    gen_op_movl_T0_0(); /* T0 = 0 */
                    s->cc_op = CC_OP_LOGICB + ot;
                    gen_op_mov_reg_T0(ot, reg); /* reg = T0 */
                    gen_op_update1_cc(); /* cpu_cc_dst = T0 */
                    break;
                } else {
                    opreg = rm;
                }
                gen_op_mov_TN_reg(ot, 1, reg); /* T1 = reg */
                gen_op(s, op, ot, opreg);
                break;
// ...
```

`gen_op` 用于生成中间指令.

```c
/* if d == OR_TMP0, it means memory operand (address in A0) 
 * 如果d == OR_TMP0,那么说明是一个内存操作数
 */
static void gen_op(DisasContext *s1, int op, int ot, int d)
{
    /* 首先将第一个操作数加载到T0寄存器 
     * 第二个操作数已经位于T1寄存器
     */
    if (d != OR_TMP0) {
        gen_op_mov_TN_reg(ot, 0, d); /* T0 = reg */
    } else {
        gen_op_ld_T0_A0(ot + s1->mem_index); /* T0= read(A0),操作数1加载到T0寄存器 */
    }
    switch(op) {
    case OP_ADCL: /* 有符号的加法 */
        if (s1->cc_op != CC_OP_DYNAMIC)
            gen_op_set_cc_op(s1->cc_op);
        gen_compute_eflags_c(cpu_tmp4); /* 计算出cf标志为,存入cpu_tmp4这个临时变量中 */
        tcg_gen_add_tl(cpu_T[0], cpu_T[0], cpu_T[1]); /* T0 += T1 */
        tcg_gen_add_tl(cpu_T[0], cpu_T[0], cpu_tmp4); /* T0 += cpu_tmp4 */
        if (d != OR_TMP0)
            gen_op_mov_reg_T0(ot, d);
        else
            gen_op_st_T0_A0(ot + s1->mem_index);
        tcg_gen_mov_tl(cpu_cc_src, cpu_T[1]);
        tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);
        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_tmp4);
        tcg_gen_shli_i32(cpu_tmp2_i32, cpu_tmp2_i32, 2);
        tcg_gen_addi_i32(cpu_cc_op, cpu_tmp2_i32, CC_OP_ADDB + ot); /* 更新模拟的cpu的cc_op的值 */
        s1->cc_op = CC_OP_DYNAMIC;
        break;
    case OP_SBBL:
        if (s1->cc_op != CC_OP_DYNAMIC)
            gen_op_set_cc_op(s1->cc_op);
        gen_compute_eflags_c(cpu_tmp4);
        tcg_gen_sub_tl(cpu_T[0], cpu_T[0], cpu_T[1]);
        tcg_gen_sub_tl(cpu_T[0], cpu_T[0], cpu_tmp4);
        if (d != OR_TMP0)
            gen_op_mov_reg_T0(ot, d);
        else
            gen_op_st_T0_A0(ot + s1->mem_index);
        tcg_gen_mov_tl(cpu_cc_src, cpu_T[1]);
        tcg_gen_mov_tl(cpu_cc_dst, cpu_T[0]);
        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_tmp4);
        tcg_gen_shli_i32(cpu_tmp2_i32, cpu_tmp2_i32, 2);
        tcg_gen_addi_i32(cpu_cc_op, cpu_tmp2_i32, CC_OP_SUBB + ot);  /* 更新模拟的cpu的cc_op的值 */
        s1->cc_op = CC_OP_DYNAMIC;
        break;
    case OP_ADDL: /* 加法指令 */
        gen_op_addl_T0_T1(); /* T0 -= T1 */
        if (d != OR_TMP0)
            gen_op_mov_reg_T0(ot, d); /* reg[d] = T0 */
        else
            gen_op_st_T0_A0(ot + s1->mem_index); /* 将结果存储到A0指示的地址中去 */
        gen_op_update2_cc(); /* 更新CC_SRC,CC_DST的值 */
        s1->cc_op = CC_OP_ADDB + ot;
        break;
    case OP_SUBL: /* 减法指令 */
        tcg_gen_sub_tl(cpu_T[0], cpu_T[0], cpu_T[1]); /* T0 -= T1 */
        if (d != OR_TMP0)
            gen_op_mov_reg_T0(ot, d);
        else
            gen_op_st_T0_A0(ot + s1->mem_index);
        gen_op_update2_cc();
        s1->cc_op = CC_OP_SUBB + ot;
        break;
    default:
   		// ...
    }
}
```



#### 总结

x86的指令又多又杂,每一条指令都分析,十分不现实.因此我只挑出其中一些比较有代表性的指令.

正如前面所涉及到的指令,它基本上就是一个简单的翻译过程,分析原有的x86指令,它的输入参数,输出参数,然后用中间指令来翻译x86指令,要注意这些点:

1. 中间指令中输出参数所在的位置应当和原始指令所在位置保持一致(内存/寄存器);
2. 一条原始指令,可能对应若干条中间指令;

不得不说,原始码->中间码的翻译,真是一个体力活.

### 收尾

当要结束翻译的时候,qemu会做两步:

```c
 gen_jmp_im(pc_ptr - dc->cs_base); /* pc_ptr是待翻译的下一条指令的地址 */
 gen_eob(dc);
```

第一件事情是将模拟cpu下一条要执行的指令地址,保存到模拟cpu的eip寄存器中去.

```c
// translate.c

/* 生成跳转指令
 * @param pc 要跳转到的地址
 */
static inline void gen_jmp_im(target_ulong pc)
{
    tcg_gen_movi_tl(cpu_tmp0, pc); /* 将pc的值移动到变量cpu_tmp0之中 */
    /* 在实际执行之中,cpu_env其实存储在一个寄存器之中 */
    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, eip)); /* 最终将值存储到所模拟cpu的eip寄存器中去 */
}

```

第二件事情是就是生成INDEX_op_exit_tb的中间指令,这个指令后面会讲,所做的事情就是返回到调用模拟cpu执行模拟代码的地方去.

```c
// tcg-op.h
static inline void tcg_gen_exit_tb(tcg_target_long val)
{
    tcg_gen_op1i(INDEX_op_exit_tb, val);
}

// translate.c
/* generate a generic end of block. Trace exception is also generated
   if needed */
static void gen_eob(DisasContext *s)
{
    if (s->cc_op != CC_OP_DYNAMIC)
        gen_op_set_cc_op(s->cc_op);
    if (s->tb->flags & HF_INHIBIT_IRQ_MASK) {
        gen_helper_reset_inhibit_irq();
    }
    if (s->singlestep_enabled) {
        gen_helper_debug();
    } else if (s->tf) {
		gen_helper_single_step();
    } else {
        tcg_gen_exit_tb(0);
    }
    s->is_jmp = 3;
}
```

## 中间码 -> 目标码

在完成中间码的翻译之后,qemu就要着手将中间吗翻译为目标码了. `tcg_gen_code`干的就是这种事情.

```c
int tcg_gen_code(TCGContext *s, uint8_t *gen_code_buf)
{
    tcg_gen_code_common(s, gen_code_buf, -1);
    /* flush instruction cache */
    flush_icache_range((unsigned long)gen_code_buf, 
                       (unsigned long)s->code_ptr);
    return s->code_ptr -  gen_code_buf;
}
```

翻译的核心函数是 `tcg_gen_code_common`,它做了这么一些事情:

1. 代码优化,`tcg_liveness_analysis`函数消除一些无用的中间指令,顺带做了一下变量的生存期分析;
2. 寄存器分配优化;
3. 代码生成.

```c
/* 代码生成 */
static inline int tcg_gen_code_common(TCGContext *s, uint8_t *gen_code_buf,
                                      long search_pc)
{
    int opc, op_index;
    const TCGOpDef *def;
    unsigned int dead_iargs;
    const TCGArg *args;
    tcg_liveness_analysis(s); /* 指令和变量的生存期分析,消除无用指令 */
    tcg_reg_alloc_start(s);

    s->code_buf = gen_code_buf;
    s->code_ptr = gen_code_buf;

    args = gen_opparam_buf;
    op_index = 0;

    for(;;) {
        opc = gen_opc_buf[op_index]; /* 获取操作符 */
        def = &tcg_op_defs[opc];
        switch(opc) {
        case INDEX_op_mov_i32:
            dead_iargs = s->op_dead_iargs[op_index];
            tcg_reg_alloc_mov(s, def, args, dead_iargs);
            break;
        case INDEX_op_movi_i32:
            tcg_reg_alloc_movi(s, args);
            break;
        case INDEX_op_debug_insn_start:
            /* debug instruction */
            break;
        case INDEX_op_nop:
        case INDEX_op_nop1:
        case INDEX_op_nop2:
        case INDEX_op_nop3:
            break;
        case INDEX_op_nopn:
            args += args[0];
            goto next;
        case INDEX_op_discard: /* discard_i32/i64 t0 */
            { /* 用于指示t0在后续指令中不会被使用 */
                TCGTemp *ts;
                ts = &s->temps[args[0]];
                /* mark the temporary as dead */
                if (!ts->fixed_reg) {
                    if (ts->val_type == TEMP_VAL_REG)
                        s->reg_to_temp[ts->reg] = -1;
                    ts->val_type = TEMP_VAL_DEAD;
                }
            }
            break;
        case INDEX_op_set_label:
            tcg_reg_alloc_bb_end(s, s->reserved_regs);
            tcg_out_label(s, args[0], (long)s->code_ptr);
            break;
        case INDEX_op_call:
            dead_iargs = s->op_dead_iargs[op_index];
            args += tcg_reg_alloc_call(s, def, opc, args, dead_iargs);
            goto next;
        case INDEX_op_end:
            goto the_end;
        default:
            /* Note: in order to speed up the code, it would be much
               faster to have specialized register allocator functions for
               some common argument patterns */
            /* 为了加快代码的运行, */
            dead_iargs = s->op_dead_iargs[op_index];
            tcg_reg_alloc_op(s, def, opc, args, dead_iargs);
            break;
        }
        args += def->nb_args;
    next:
        if (search_pc >= 0 && search_pc < s->code_ptr - gen_code_buf) {
            return op_index;
        }
        op_index++;
    }
 the_end:
    return -1;
}
```

### 变量生存期分析

`tcg_liveness_analysis` 用于做中间码的优化,它致力于做两件事情:

1. 消除那些无用的代码.
2. 标记那些dead状态的输入参数,也就是opc_dead_iargs, 每一条指令都有这样的一个变量与之对应,如果opc_dead_iargs的第i个bit为1,它表示执行完该中间指令之后,后续指令不再使用该指令的第i个输入参数.

变量和指令的生存期分析,可以带来很好的性能提升.

```c
/* Liveness analysis : update the opc_dead_iargs array to tell if a
   given input arguments is dead. Instructions updating dead
   temporaries are removed. */
/* 生存期分析,更新opc_dead_iargs数组 */
static void tcg_liveness_analysis(TCGContext *s)
{
    int i, op_index, op, nb_args, nb_iargs, nb_oargs, arg, nb_ops;
    TCGArg *args;
    const TCGOpDef *def;
    uint8_t *dead_temps;
    unsigned int dead_iargs;
    
    gen_opc_ptr++; /* skip end */
    nb_ops = gen_opc_ptr - gen_opc_buf; /* 指令条数 */
    s->op_dead_iargs = tcg_malloc(OPC_BUF_SIZE * sizeof(uint16_t));
    
    dead_temps = tcg_malloc(s->nb_temps);
    memset(dead_temps, 1, s->nb_temps); /* 默认所有的指令都有效 */

    args = gen_opparam_ptr;
    op_index = nb_ops - 1;
    /* 从最后一条指令开始,向前推导 */
    while (op_index >= 0) {
        op = gen_opc_buf[op_index]; /* 操作码 */
        def = &tcg_op_defs[op]; /* 操作码的相关定义 */
        switch(op) {
        case INDEX_op_call:
            {
                int call_flags;
                nb_args = args[-1]; /* 参数个数 */
                args -= nb_args;
                nb_iargs = args[0] & 0xffff;
                nb_oargs = args[0] >> 16;
                args++;
                call_flags = args[nb_oargs + nb_iargs];
                /* pure functions can be removed if their result is not used */
                if (call_flags & TCG_CALL_PURE) {
                    for(i = 0; i < nb_oargs; i++) {
                        arg = args[i];
                        if (!dead_temps[arg])
                            goto do_not_remove_call;
                    }
                    tcg_set_nop(s, gen_opc_buf + op_index, args - 1, nb_args);
                } else {
                do_not_remove_call:
                    /* output args are dead */
                    for(i = 0; i < nb_oargs; i++) {
                        arg = args[i];
                        dead_temps[arg] = 1;
                    }
                    /* globals are live (they may be used by the call) */
                    memset(dead_temps, 0, s->nb_globals);
                    
                    /* input args are live */
                    dead_iargs = 0;
                    for(i = 0; i < nb_iargs; i++) {
                        arg = args[i + nb_oargs];
                        if (arg != TCG_CALL_DUMMY_ARG) {
                            if (dead_temps[arg]) {
                                dead_iargs |= (1 << i);
                            }
                            dead_temps[arg] = 0; /* 输入参数处于live状态 */
                        }
                    }
                    s->op_dead_iargs[op_index] = dead_iargs;
                }
                args--;
            }
            break;
        case INDEX_op_set_label:
            args--;
            /* mark end of basic block */
            tcg_la_bb_end(s, dead_temps);
            break;
        case INDEX_op_debug_insn_start:
            args -= def->nb_args;
            break;
        case INDEX_op_nopn:
            nb_args = args[-1];
            args -= nb_args;
            break;
        case INDEX_op_discard:
            args--;
            /* mark the temporary as dead */
            dead_temps[args[0]] = 1;
            break;
        case INDEX_op_end:
            break;
        default:
            args -= def->nb_args; /* 参数数组 */
            nb_iargs = def->nb_iargs; /* 输入参数个数 */
            nb_oargs = def->nb_oargs; /* 输出参数个数 */

            /* Test if the operation can be removed because all
               its outputs are dead. We assume that nb_oargs == 0
               implies side effects */
            /* 检测一下,是否指令可以消除,什么时候一条指令可以消除呢?很简单,那就是后续指令压根就
             * 不关心它的输出.
             */
            if (!(def->flags & TCG_OPF_SIDE_EFFECTS) && nb_oargs != 0) {
                for(i = 0; i < nb_oargs; i++) { /* 分析输出参数 */
                    arg = args[i];
                    if (!dead_temps[arg]) /* 输出参数被后续指令引用,因此不能移除 */
                        goto do_not_remove;
                }
                /* 否则的话,指令是可以消除的 */
                tcg_set_nop(s, gen_opc_buf + op_index, args, def->nb_args); /* 直接用空指令覆盖 */
            } else { /* (nb_args == 0) || (def->flags & TCG_OPF_SIDE_EFFECTS) */
            do_not_remove:
                /* output args are dead 
                 * 首先默认所有输出参数都属于dead状态
                 */
                for(i = 0; i < nb_oargs; i++) {
                    arg = args[i];
                    /* 我其实很好奇,为什么要将这个参数标记为dead, 首先我们说明一点,那就是
                     * 这些输出参数只会影响下一条指令
                     */
                    dead_temps[arg] = 1;
                }

                /* if end of basic block, update */
                if (def->flags & TCG_OPF_BB_END) {
                    tcg_la_bb_end(s, dead_temps);
                } else if (def->flags & TCG_OPF_CALL_CLOBBER) {
                    /* globals are live */
                    memset(dead_temps, 0, s->nb_globals);
                }

                /* input args are live */
                /* 输入参数都处于live状态
                 * dead_temps是共享的.
                 * 这其实也以为着,之前指令对应的参数处于live状态
                 */
                dead_iargs = 0; /* 解析所谓的input 参数 */
                for (i = 0; i < nb_iargs; i++) {
                    arg = args[i + nb_oargs]; /* 获得输入参数 */
                    if (dead_temps[arg]) { /* 后续指令不再使用第i个输入参数arg */
                        dead_iargs |= (1 << i); /* 第i个输入参数处于dead状态 */
                    }
                    dead_temps[arg] = 0; /* 因为产生了依赖,所以不算dead */
                }
                s->op_dead_iargs[op_index] = dead_iargs;
            }
            break;
        }
        op_index--; /* 向前推一条指令 */
    }
    if (args != gen_opparam_buf)
        tcg_abort();
}
```

### move指令

```c
/* 为move指令生成目标码
 * mov_i32/i64 t0, t1
 * t0 = t1
 * Move t1 to t0 (both operands must have the same type).
 */
static void tcg_reg_alloc_mov(TCGContext *s, const TCGOpDef *def,
                              const TCGArg *args,
                              unsigned int dead_iargs)
{
    TCGTemp *ts, *ots;
    int reg;
    const TCGArgConstraint *arg_ct;
    /* 两个参数都放在temps之中吗? */
    ots = &s->temps[args[0]]; /* ots为输出参数 */
    ts = &s->temps[args[1]]; /* ts为输入参数 */
    arg_ct = &def->args_ct[0]; /* 参数限定 */

    if (ts->val_type == TEMP_VAL_REG) { /* 输入参数在寄存器之中 */
        /* 第1个输入参数在之后的指令中都不会被使用 */
        if (IS_DEAD_IARG(0) && !ts->fixed_reg && !ots->fixed_reg) {
            /* the mov can be suppressed */
            if (ots->val_type == TEMP_VAL_REG)
                s->reg_to_temp[ots->reg] = -1;
            reg = ts->reg;
            s->reg_to_temp[reg] = -1;
            ts->val_type = TEMP_VAL_DEAD; /* 将参数标记为TEMP_VAL_DEAD,方便后续寄存器回收 */
        } else {
            if (ots->val_type == TEMP_VAL_REG) {
                reg = ots->reg;
            } else {
                reg = tcg_reg_alloc(s, arg_ct->u.regs, s->reserved_regs); /* 分配一个寄存器 */
            }
            if (ts->reg != reg) {
                /* 将输入参数移动到寄存器reg之中 */
                tcg_out_mov(s, reg, ts->reg);
            }
        }
    } else if (ts->val_type == TEMP_VAL_MEM) { /* 输入参数位于内存之中 */
        if (ots->val_type == TEMP_VAL_REG) { /* 输出参数应当位于寄存器之中 */
            reg = ots->reg;
        } else { /* 非寄存器参数 */
            reg = tcg_reg_alloc(s, arg_ct->u.regs, s->reserved_regs); /* 分配一个寄存器 */
        }
        /* 将输入参数加载到寄存器reg */
        tcg_out_ld(s, ts->type, reg, ts->mem_reg, ts->mem_offset);
    } else if (ts->val_type == TEMP_VAL_CONST) { /* 输入参数为一个常量 */
        if (ots->fixed_reg) { /* 输出参数使用一个固定的寄存器 */
            reg = ots->reg;
            tcg_out_movi(s, ots->type, reg, ts->val); /* 将输入参数移动到reg */
        } else {
            /* propagate constant */
            if (ots->val_type == TEMP_VAL_REG)
                s->reg_to_temp[ots->reg] = -1;
            ots->val_type = TEMP_VAL_CONST;
            ots->val = ts->val;
            return;
        }
    } else {
        tcg_abort();
    }
    s->reg_to_temp[reg] = args[0];
    ots->reg = reg; /* 输出到reg */
    ots->val_type = TEMP_VAL_REG;
    ots->mem_coherent = 0;
}
```

### call指令

```c
/* 为call指令生成目标码
 * call <ret> <params> ptr
 * call function 'ptr' (pointer type)
 * <ret> optional 32 bit or 64 bit return value
 * <params> optional 32 bit or 64 bit parameters
 */
static int tcg_reg_alloc_call(TCGContext *s, const TCGOpDef *def,
                              int opc, const TCGArg *args,
                              unsigned int dead_iargs)
{
    int nb_iargs, nb_oargs, flags, nb_regs, i, reg, nb_params;
    TCGArg arg, func_arg;
    TCGTemp *ts;
    tcg_target_long stack_offset, call_stack_size, func_addr;
    int const_func_arg, allocate_args;
    TCGRegSet allocated_regs;
    const TCGArgConstraint *arg_ct;
    arg = *args++;
    nb_oargs = arg >> 16; /* 输出参数的个数 */
    nb_iargs = arg & 0xffff; /* 输入参数的个数 */
    nb_params = nb_iargs - 1; /* 调用参数的个数 */

    flags = args[nb_oargs + nb_iargs];
	/* nb_regs表示,寄存器最多只能保存nb_regs个参数 */
    nb_regs = tcg_target_get_call_iarg_regs_count(flags);
    if (nb_regs > nb_params)
        nb_regs = nb_params;

    /* assign stack slots first */
    /* XXX: preallocate call stack */
    call_stack_size = (nb_params - nb_regs) * sizeof(tcg_target_long); /* 调用栈的大小 */
    call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & 
        ~(TCG_TARGET_STACK_ALIGN - 1);
    allocate_args = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE);
    if (allocate_args) {
        tcg_out_addi(s, TCG_REG_CALL_STACK, -STACK_DIR(call_stack_size));
    }

    stack_offset = TCG_TARGET_CALL_STACK_OFFSET;
    for(i = nb_regs; i < nb_params; i++) { /* 首先将多余的参数压栈 */
        arg = args[nb_oargs + i];
#ifdef TCG_TARGET_STACK_GROWSUP
        stack_offset -= sizeof(tcg_target_long);
#endif
        if (arg != TCG_CALL_DUMMY_ARG) {
            ts = &s->temps[arg];
            if (ts->val_type == TEMP_VAL_REG) { /* 参数在寄存器之中 */
                /* 存储到内存变量之中 */
                tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset);
            } else if (ts->val_type == TEMP_VAL_MEM) { /* 参数在内存之中 */
                reg = tcg_reg_alloc(s, tcg_target_available_regs[ts->type], 
                                    s->reserved_regs);
                /* XXX: not correct if reading values from the stack */
                tcg_out_ld(s, ts->type, reg, ts->mem_reg, ts->mem_offset); /* 将参数加载至寄存器 */
                tcg_out_st(s, ts->type, reg, TCG_REG_CALL_STACK, stack_offset); /* 然后放入堆栈 */
            } else if (ts->val_type == TEMP_VAL_CONST) { /* 参数是一个常量 */
                reg = tcg_reg_alloc(s, tcg_target_available_regs[ts->type], 
                                    s->reserved_regs);
                /* XXX: sign extend may be needed on some targets */
                tcg_out_movi(s, ts->type, reg, ts->val);
                tcg_out_st(s, ts->type, reg, TCG_REG_CALL_STACK, stack_offset); /* 然后放入堆栈 */
            } else {
                tcg_abort();
            }
        }
#ifndef TCG_TARGET_STACK_GROWSUP
        stack_offset += sizeof(tcg_target_long);
#endif
    }
    
    /* assign input registers */
    tcg_regset_set(allocated_regs, s->reserved_regs);
    for(i = 0; i < nb_regs; i++) {
        arg = args[nb_oargs + i];
        if (arg != TCG_CALL_DUMMY_ARG) {
            ts = &s->temps[arg];
            reg = tcg_target_call_iarg_regs[i]; /* 获取寄存器 */
            tcg_reg_free(s, reg);
            if (ts->val_type == TEMP_VAL_REG) {
                if (ts->reg != reg) {
                    tcg_out_mov(s, reg, ts->reg);
                }
            } else if (ts->val_type == TEMP_VAL_MEM) {
                /* 将变量的值加载到寄存器中 */
                tcg_out_ld(s, ts->type, reg, ts->mem_reg, ts->mem_offset);
            } else if (ts->val_type == TEMP_VAL_CONST) {
                /* XXX: sign extend ? */
                tcg_out_movi(s, ts->type, reg, ts->val);
            } else {
                tcg_abort();
            }
            tcg_regset_set_reg(allocated_regs, reg);
        }
    }
    
    /* assign function address */
    func_arg = args[nb_oargs + nb_iargs - 1]; /* 获得函数地址 */
    arg_ct = &def->args_ct[0];
    ts = &s->temps[func_arg];
    func_addr = ts->val; /* 函数地址 */
    const_func_arg = 0;
    if (ts->val_type == TEMP_VAL_MEM) { /* 地址位于内存之中 */
        reg = tcg_reg_alloc(s, arg_ct->u.regs, allocated_regs);
        tcg_out_ld(s, ts->type, reg, ts->mem_reg, ts->mem_offset); /* 加载至寄存器 */
        func_arg = reg;
        tcg_regset_set_reg(allocated_regs, reg);
    } else if (ts->val_type == TEMP_VAL_REG) {
        reg = ts->reg;
        if (!tcg_regset_test_reg(arg_ct->u.regs, reg)) {
            reg = tcg_reg_alloc(s, arg_ct->u.regs, allocated_regs);
            tcg_out_mov(s, reg, ts->reg);
        }
        func_arg = reg;
        tcg_regset_set_reg(allocated_regs, reg); /* 标记寄存器reg已经被使用 */
    } else if (ts->val_type == TEMP_VAL_CONST) {
        if (tcg_target_const_match(func_addr, arg_ct)) {
            const_func_arg = 1;
            func_arg = func_addr;
        } else {
            reg = tcg_reg_alloc(s, arg_ct->u.regs, allocated_regs);
            tcg_out_movi(s, ts->type, reg, func_addr);
            func_arg = reg;
            tcg_regset_set_reg(allocated_regs, reg);
        }
    }   
    
    /* mark dead temporaries and free the associated registers */
    /* 标记那些不再使用的临时变量,释放掉对应的寄存器 */
    for(i = 0; i < nb_iargs; i++) {
        arg = args[nb_oargs + i];
        if (IS_DEAD_IARG(i)) {
            ts = &s->temps[arg];
            if (!ts->fixed_reg) {
                if (ts->val_type == TEMP_VAL_REG)
                    s->reg_to_temp[ts->reg] = -1;
                ts->val_type = TEMP_VAL_DEAD;
            }
        }
    }
    
    /* clobber call registers */
    /* 清除调用寄存器 */
    for(reg = 0; reg < TCG_TARGET_NB_REGS; reg++) {
        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, reg)) {
            tcg_reg_free(s, reg);
        }
    }
    
    /* store globals and free associated registers (we assume the call
       can modify any global. */
    save_globals(s, allocated_regs);
    tcg_out_op(s, opc, &func_arg, &const_func_arg); /* 生成call指令 */
    
    if (allocate_args) {
        /* 堆栈寄存器要修改 */
        tcg_out_addi(s, TCG_REG_CALL_STACK, STACK_DIR(call_stack_size));
    }

    /* assign output registers and emit moves if needed */
    for(i = 0; i < nb_oargs; i++) { /* 遍历输出参数 */
        arg = args[i];
        ts = &s->temps[arg];
        reg = tcg_target_call_oarg_regs[i];
        assert(s->reg_to_temp[reg] == -1);
        if (ts->fixed_reg) {
            if (ts->reg != reg) {
                tcg_out_mov(s, ts->reg, reg);
            }
        } else {
            if (ts->val_type == TEMP_VAL_REG)
                s->reg_to_temp[ts->reg] = -1;
            ts->val_type = TEMP_VAL_REG;
            ts->reg = reg;
            ts->mem_coherent = 0; 
            s->reg_to_temp[reg] = arg;
        }
    }   
    return nb_iargs + nb_oargs + def->nb_cargs + 1;
}
```

### 其他指令

```c
/* 为各种op生成目标码 */
static void tcg_reg_alloc_op(TCGContext *s, 
                             const TCGOpDef *def, int opc,
                             const TCGArg *args,
                             unsigned int dead_iargs)
{
    TCGRegSet allocated_regs;
    int i, k, nb_iargs, nb_oargs, reg;
    TCGArg arg;
    const TCGArgConstraint *arg_ct;
    TCGTemp *ts;
    TCGArg new_args[TCG_MAX_OP_ARGS];
    int const_args[TCG_MAX_OP_ARGS];

    nb_oargs = def->nb_oargs; /* 输出参数的个数 */
    nb_iargs = def->nb_iargs; /* 输入参数的个数 */

    /* copy constants */
    memcpy(new_args + nb_oargs + nb_iargs, 
           args + nb_oargs + nb_iargs, 
           sizeof(TCGArg) * def->nb_cargs);

    /* satisfy input constraints 
     * 首先要满足输入限定
     */ 
    tcg_regset_set(allocated_regs, s->reserved_regs); /* 被保留的寄存器不能够被分配 */
    for(k = 0; k < nb_iargs; k++) { /* 先处理输入参数 */
        i = def->sorted_args[nb_oargs + k];
        arg = args[i]; /* 获得参数的标号 */
        arg_ct = &def->args_ct[i]; /* 限定信息 */
        ts = &s->temps[arg]; /* 获得参数信息 */
        if (ts->val_type == TEMP_VAL_MEM) { /* 输入参数位于内存之中 */
            /* 分配一个可用的寄存器 */
            reg = tcg_reg_alloc(s, arg_ct->u.regs, allocated_regs);
            /* 将内存中的值加载到寄存器reg之中 */
            tcg_out_ld(s, ts->type, reg, ts->mem_reg, ts->mem_offset);
            ts->val_type = TEMP_VAL_REG; /* 更新参数的位置信息 */
            ts->reg = reg;
            ts->mem_coherent = 1; /* 内存和寄存器一致?? */
            s->reg_to_temp[reg] = arg;
        } else if (ts->val_type == TEMP_VAL_CONST) { /* 输入参数是一个常量 */
            if (tcg_target_const_match(ts->val, arg_ct)) {
                /* constant is OK for instruction */
                const_args[i] = 1; /* 参数是常量 */
                new_args[i] = ts->val; /* 记录下常量的值 */
                goto iarg_end;
            } else {
                /* need to move to a register */
                reg = tcg_reg_alloc(s, arg_ct->u.regs, allocated_regs);
                /* 然后移动到分配的寄存器中去 */
                tcg_out_movi(s, ts->type, reg, ts->val);
                ts->val_type = TEMP_VAL_REG;
                ts->reg = reg;
                ts->mem_coherent = 0;
                s->reg_to_temp[reg] = arg; /* 要从寄存器移动到temp中去 */
            }
        }
        assert(ts->val_type == TEMP_VAL_REG);
        if (arg_ct->ct & TCG_CT_IALIAS) { /* 参数被引用 */
            if (ts->fixed_reg) { /* 使用一个固定的寄存器 */
                /* if fixed register, we must allocate a new register
                   if the alias is not the same register */
                if (arg != args[arg_ct->alias_index])
                    goto allocate_in_reg;
            } else {
                /* if the input is aliased to an output and if it is
                   not dead after the instruction, we must allocate
                   a new register and move it */
                if (!IS_DEAD_IARG(i - nb_oargs)) 
                    goto allocate_in_reg;
            }
        }
        reg = ts->reg;
        if (tcg_regset_test_reg(arg_ct->u.regs, reg)) {
            /* nothing to do : the constraint is satisfied */
        } else {
        allocate_in_reg:
            /* 分配一个新的寄存器 */
            reg = tcg_reg_alloc(s, arg_ct->u.regs, allocated_regs);
            /* 输入参数移动到寄存器中去 */
            tcg_out_mov(s, reg, ts->reg);
        }
        new_args[i] = reg; /* 记录下参数值 */
        const_args[i] = 0; /* 非常量 */
        tcg_regset_set_reg(allocated_regs, reg);
    iarg_end: ;
    }
    
    if (def->flags & TCG_OPF_BB_END) {
        tcg_reg_alloc_bb_end(s, allocated_regs);
    } else {
        /* mark dead temporaries and free the associated registers
         * 标记无用的临时变量,释放对应的寄存器
         */
        for(i = 0; i < nb_iargs; i++) { /* 遍历输入参数 */
            arg = args[nb_oargs + i]; /* 参数的标号 */
            if (IS_DEAD_IARG(i)) { /*  后续指令已经不会再使用参数i */
                ts = &s->temps[arg]; /* 获得输入参数信息 */
                if (!ts->fixed_reg) { /* 不使用固定的寄存器 */
                    if (ts->val_type == TEMP_VAL_REG)
                        s->reg_to_temp[ts->reg] = -1; /* 没有必要将值从寄存器转移到内存 */
                    ts->val_type = TEMP_VAL_DEAD; /* 以后再也用不到这个变量,方便内存回收 */
                }
            }
        }
        
        if (def->flags & TCG_OPF_CALL_CLOBBER) {
            /* XXX: permit generic clobber register list ? */ 
            for(reg = 0; reg < TCG_TARGET_NB_REGS; reg++) {
                if (tcg_regset_test_reg(tcg_target_call_clobber_regs, reg)) {
                    tcg_reg_free(s, reg);
                }
            }
            /* XXX: for load/store we could do that only for the slow path
               (i.e. when a memory callback is called) */
            
            /* store globals and free associated registers (we assume the insn
               can modify any global. */
            save_globals(s, allocated_regs);
        }
        
        /* satisfy the output constraints */
        tcg_regset_set(allocated_regs, s->reserved_regs);
        for (k = 0; k < nb_oargs; k++) { /* 遍历输出参数 */
            i = def->sorted_args[k];
            arg = args[i];
            arg_ct = &def->args_ct[i];
            ts = &s->temps[arg];
            if (arg_ct->ct & TCG_CT_ALIAS) {
                reg = new_args[arg_ct->alias_index];
            } else {
                /* if fixed register, we try to use it */
                reg = ts->reg;
                if (ts->fixed_reg &&
                    tcg_regset_test_reg(arg_ct->u.regs, reg)) {
                    goto oarg_end;
                }
                /* 如果不能使用指定的寄存器,那么重新分配一个 */
                reg = tcg_reg_alloc(s, arg_ct->u.regs, allocated_regs);
            }
            tcg_regset_set_reg(allocated_regs, reg); /* 记录下已经分配了的寄存器 */
            /* if a fixed register is used, then a move will be done afterwards */
            if (!ts->fixed_reg) {
                if (ts->val_type == TEMP_VAL_REG)
                    s->reg_to_temp[ts->reg] = -1;
                ts->val_type = TEMP_VAL_REG;
                ts->reg = reg;
                /* temp value is modified, so the value kept in memory is
                   potentially not the same 
                */
                /* 临时值被修改了,因此保存在内存中的值也不再一样? */
                ts->mem_coherent = 0; 
                s->reg_to_temp[reg] = arg;
            }
        oarg_end:
            new_args[i] = reg;
        }
    }

    /* emit instruction 
     * 指令生成
     */
    tcg_out_op(s, opc, new_args, const_args);
    
    /* move the outputs in the correct register if needed 
     * 如果必要的话,将输出结果输出到对应的寄存器中去
     */
    for(i = 0; i < nb_oargs; i++) {
        ts = &s->temps[args[i]];
        reg = new_args[i]; /* 新的参数值所在的寄存器 */
        if (ts->fixed_reg && ts->reg != reg) {
            /* 生成mov指令 */
            tcg_out_mov(s, ts->reg, reg);
        }
    }
}
```

### 目标码生成

目标码的生成,思想很简单,那就是用目标平台的指令来翻译中间指令,大部分的中间指令和目标指令可以做到一对一直接翻译,只有一小部分中间指令,需要若干条目标指令来翻译.

```c
/* 将中间码转换为目标码 */
static inline void tcg_out_op(TCGContext *s, int opc, const TCGArg *args, const int *const_args)
{
    int c;
    switch(opc) {
    case INDEX_op_exit_tb:
        tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_RAX, args[0]);
        tcg_out8(s, 0xe9); /* jmp tb_ret_addr */
        tcg_out32(s, tb_ret_addr - s->code_ptr - 4);
        break;
    case INDEX_op_goto_tb:
        if (s->tb_jmp_offset) {
            /* direct jump method */
            tcg_out8(s, 0xe9); /* jmp im */
            s->tb_jmp_offset[args[0]] = s->code_ptr - s->code_buf;
            tcg_out32(s, 0);
        } else {
            /* indirect jump method */
            /* jmp Ev */
            tcg_out_modrm_offset(s, 0xff, 4, -1, 
                                 (tcg_target_long)(s->tb_next + args[0]));
        }
        s->tb_next_offset[args[0]] = s->code_ptr - s->code_buf;
        break;
    case INDEX_op_call:
        if (const_args[0]) {
            tcg_out8(s, 0xe8); /* 0xe8是call指令 */
            tcg_out32(s, args[0] - (tcg_target_long)s->code_ptr - 4);
        } else { /* 0xff也是call指令 */
            tcg_out_modrm(s, 0xff, 2, args[0]);
        }
        break;
    case INDEX_op_jmp:
        if (const_args[0]) {
            tcg_out8(s, 0xe9);
            tcg_out32(s, args[0] - (tcg_target_long)s->code_ptr - 4);
        } else {
            tcg_out_modrm(s, 0xff, 4, args[0]);
        }
        break;
    case INDEX_op_br:
        tcg_out_jxx(s, JCC_JMP, args[0]);
        break;
    case INDEX_op_movi_i32:
        tcg_out_movi(s, TCG_TYPE_I32, args[0], (uint32_t)args[1]);
        break;
    case INDEX_op_ld8u_i32:
        /* movzbl */
        tcg_out_modrm_offset(s, 0xb6 | P_EXT, args[0], args[1], args[2]);
        break;
    case INDEX_op_ld8s_i32:
        /* movsbl */
        tcg_out_modrm_offset(s, 0xbe | P_EXT, args[0], args[1], args[2]);
        break;
    case INDEX_op_ld16u_i32:
        /* movzwl */
        tcg_out_modrm_offset(s, 0xb7 | P_EXT, args[0], args[1], args[2]);
        break;
    case INDEX_op_ld16s_i32:
        /* movswl */
        tcg_out_modrm_offset(s, 0xbf | P_EXT, args[0], args[1], args[2]);
        break;
    case INDEX_op_ld_i32:
        /* movl */
        tcg_out_modrm_offset(s, 0x8b, args[0], args[1], args[2]);
        break;
        
    case INDEX_op_st8_i32:
        /* movb */
        tcg_out_modrm_offset(s, 0x88 | P_REXB, args[0], args[1], args[2]);
        break;
    case INDEX_op_st16_i32:
        /* movw */
        tcg_out8(s, 0x66);
        tcg_out_modrm_offset(s, 0x89, args[0], args[1], args[2]);
        break;

    case INDEX_op_sub_i32:
        c = ARITH_SUB;
        goto gen_arith32;
    case INDEX_op_and_i32:
        c = ARITH_AND;
        goto gen_arith32;
    case INDEX_op_or_i32:
        c = ARITH_OR;
        goto gen_arith32;
    case INDEX_op_xor_i32:
        c = ARITH_XOR;
        goto gen_arith32;
    case INDEX_op_add_i32:
        c = ARITH_ADD;
    gen_arith32:
        if (const_args[2]) {
            tgen_arithi32(s, c, args[0], args[2]);
        } else {
            tcg_out_modrm(s, 0x01 | (c << 3), args[2], args[0]);
        }
        break;

    case INDEX_op_mul_i32:
        if (const_args[2]) {
            int32_t val;
            val = args[2];
            if (val == (int8_t)val) {
                tcg_out_modrm(s, 0x6b, args[0], args[0]);
                tcg_out8(s, val);
            } else {
                tcg_out_modrm(s, 0x69, args[0], args[0]);
                tcg_out32(s, val);
            }
        } else {
            tcg_out_modrm(s, 0xaf | P_EXT, args[0], args[2]);
        }
        break;
    case INDEX_op_div2_i32:
        tcg_out_modrm(s, 0xf7, 7, args[4]);
        break;
    case INDEX_op_divu2_i32:
        tcg_out_modrm(s, 0xf7, 6, args[4]);
        break;

    case INDEX_op_shl_i32:
        c = SHIFT_SHL;
    gen_shift32:
        if (const_args[2]) {
            if (args[2] == 1) {
                tcg_out_modrm(s, 0xd1, c, args[0]);
            } else {
                tcg_out_modrm(s, 0xc1, c, args[0]);
                tcg_out8(s, args[2]);
            }
        } else {
            tcg_out_modrm(s, 0xd3, c, args[0]);
        }
        break;
    case INDEX_op_shr_i32:
        c = SHIFT_SHR;
        goto gen_shift32;
    case INDEX_op_sar_i32:
        c = SHIFT_SAR;
        goto gen_shift32;
        
    case INDEX_op_brcond_i32:
        tcg_out_brcond(s, args[2], args[0], args[1], const_args[1], 
                       args[3], 0);
        break;

    case INDEX_op_bswap_i32:
        tcg_out_opc(s, (0xc8 + (args[0] & 7)) | P_EXT, 0, args[0], 0);
        break;

    case INDEX_op_neg_i32:
        tcg_out_modrm(s, 0xf7, 3, args[0]);
        break;

    case INDEX_op_ext8s_i32:
        tcg_out_modrm(s, 0xbe | P_EXT | P_REXB, args[0], args[1]);
        break;
    case INDEX_op_ext16s_i32:
        tcg_out_modrm(s, 0xbf | P_EXT, args[0], args[1]);
        break;
    case INDEX_op_qemu_ld8u:
        tcg_out_qemu_ld(s, args, 0);
        break;
    case INDEX_op_qemu_ld8s:
        tcg_out_qemu_ld(s, args, 0 | 4);
        break;
    case INDEX_op_qemu_ld16u:
        tcg_out_qemu_ld(s, args, 1);
        break;
    case INDEX_op_qemu_ld16s:
        tcg_out_qemu_ld(s, args, 1 | 4);
        break;
    case INDEX_op_qemu_ld32u:
        tcg_out_qemu_ld(s, args, 2);
        break;
    case INDEX_op_qemu_ld32s:
        tcg_out_qemu_ld(s, args, 2 | 4);
        break;  
    case INDEX_op_qemu_st8:
        tcg_out_qemu_st(s, args, 0);
        break;
    case INDEX_op_qemu_st16:
        tcg_out_qemu_st(s, args, 1);
        break;
    case INDEX_op_qemu_st32:
        tcg_out_qemu_st(s, args, 2);
        break;
    default:
        tcg_abort();
    }
}
```

我这里单独拎几条指令来分析一下:

#### INDEX_op_exit_tb

```c
//...
    case INDEX_op_exit_tb:
        tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_RAX, args[0]); /* 将参数1放入RAX寄存器 */
        tcg_out8(s, 0xe9); /* jmp tb_ret_addr */
        tcg_out32(s, tb_ret_addr - s->code_ptr - 4);
        break;
//...
```

INDEX_op_exit_tb指令的实现十分有意思,它主要做了两件事情:

1. 将参数1放入RAX寄存器,作为返回值(可以参考gen_eob,这个值一般是0).
2. 跳转到tb_ret_addr对应的指令去执行,注意我们前面说过的,tb_ret_addr记录的是epilogue指令的起始位置,这里相当于返回.

